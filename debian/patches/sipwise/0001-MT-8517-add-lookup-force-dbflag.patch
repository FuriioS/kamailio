From f04851984efe68c101d3d80b9e02a722a6c8b80a Mon Sep 17 00:00:00 2001
From: Victor Seva <linuxmaniac@torreviejawireless.org>
Date: Wed, 6 Aug 2014 16:45:00 +0200
Subject: [PATCH] MT#8517 add lookup force dbflag

Now we can force lookup to read from DB
---
 modules/registrar/api.c     | 15 +++++++++
 modules/registrar/api.h     |  4 +++
 modules/registrar/lookup.c  | 36 ++++++++++++++++++---
 modules/registrar/lookup.h  |  6 ++++
 modules/registrar/reg_mod.c | 32 +++++++++++++++---
 modules/usrloc/udomain.c    | 79 ++++++++++++++++++++++++++++++++++++++++++---
 modules/usrloc/udomain.h    | 23 +++++++++++++
 modules/usrloc/usrloc.c     |  3 ++
 modules/usrloc/usrloc.h     |  7 ++++
 9 files changed, 191 insertions(+), 14 deletions(-)

--- a/modules/registrar/api.c
+++ b/modules/registrar/api.c
@@ -96,6 +96,21 @@
 /**
  *
  */
+int regapi_lookup_db(struct sip_msg *msg, char *table)
+{
+	udomain_t* d;
+
+	if(ul.get_udomain(table, &d)<0)
+	{
+		LM_ERR("usrloc domain [%s] not found\n", table);
+		return -1;
+	}
+	return lookup_db(msg, d, NULL);
+}
+
+/**
+ *
+ */
 int regapi_registered(struct sip_msg *msg, char *table)
 {
 	udomain_t* d;
--- a/modules/registrar/api.h
+++ b/modules/registrar/api.h
@@ -43,6 +43,9 @@
 typedef int (*regapi_lookup_uri_f)(struct sip_msg *msg, char *table, str *uri);
 int regapi_lookup_uri(struct sip_msg *msg, char *table, str *uri);
 
+typedef int (*regapi_lookup_db_f)(struct sip_msg *msg, char *table);
+int regapi_lookup_db(struct sip_msg *msg, char *table);
+
 typedef int (*regapi_set_q_override_f)(struct sip_msg *msg, str *new_q);
 int regapi_set_q_override(struct sip_msg *msg, str *new_q);
 
@@ -54,6 +57,7 @@
 	regapi_save_uri_f   save_uri;
 	regapi_lookup_f     lookup;
 	regapi_lookup_uri_f lookup_uri;
+	regapi_lookup_db_f     lookup_db;
 	regapi_lookup_f     registered;
 	regapi_set_q_override_f set_q_override;
 } registrar_api_t;
--- a/modules/registrar/lookup.c
+++ b/modules/registrar/lookup.c
@@ -87,7 +87,7 @@
  *          -2 : found but method not allowed
  *          -3 : error
  */
-int lookup(struct sip_msg* _m, udomain_t* _d, str* _uri)
+int _lookup(struct sip_msg* _m, udomain_t* _d, str* _uri, unsigned int _dbflag)
 {
 	urecord_t* r;
 	str aor, uri;
@@ -109,7 +109,7 @@
 
 	if (_m->new_uri.s) uri = _m->new_uri;
 	else uri = _m->first_line.u.request.uri;
-	
+
 	if (extract_aor((_uri)?_uri:&uri, &aor, &puri) < 0) {
 		LM_ERR("failed to extract address of record\n");
 		return -3;
@@ -153,7 +153,10 @@
 	{
 		/* aor or pub-gruu lookup */
 		ul.lock_udomain(_d, &aor);
-		res = ul.get_urecord(_d, &aor, &r);
+		if(_dbflag)
+			res = ul.get_urecord_db(_d, &aor, &r);
+		else
+			res = ul.get_urecord(_d, &aor, &r);
 		if (res > 0) {
 			LM_DBG("'%.*s' Not found in usrloc\n", aor.len, ZSW(aor.s));
 			ul.unlock_udomain(_d, &aor);
@@ -196,7 +199,10 @@
 		}
 	} else {
 		/* temp-gruu lookup */
-		res = ul.get_urecord_by_ruid(_d, ahash, &inst, &r, &ptr);
+		if(_dbflag)
+			res = ul.get_urecord_by_ruid_db(_d, ahash, &inst, &r, &ptr);
+		else
+			res = ul.get_urecord_by_ruid(_d, ahash, &inst, &r, &ptr);
 		if(res<0) {
 			LM_DBG("temp gruu '%.*s' not found in usrloc\n", aor.len, ZSW(aor.s));
 			return -1;
@@ -353,6 +359,28 @@
 	return ret;
 }
 
+/*! \brief
+ * Lookup contact in the database and rewrite Request-URI
+ * \return: -1 : not found
+ *          -2 : found but method not allowed
+ *          -3 : error
+ */
+int lookup(struct sip_msg* _m, udomain_t* _d, str* _uri)
+{
+	return _lookup(_m, _d, _uri, 0);
+}
+
+/*! \brief
+ * Lookup contact in the database and rewrite Request-URI
+ * ( error if usrloc in NO_DB mode)
+ * \return: -1 : not found
+ *          -2 : found but method not allowed
+ *          -3 : error
+ */
+int lookup_db(struct sip_msg* _m, udomain_t* _d, str* _uri)
+{
+	return _lookup(_m, _d, _uri, 1);
+}
 
 int reset_ruri_branch(sip_msg_t *msg)
 {
--- a/modules/registrar/lookup.h
+++ b/modules/registrar/lookup.h
@@ -42,6 +42,12 @@
 int lookup(struct sip_msg* _m, udomain_t* _d, str* _uri);
 
 /*! \brief
+ * Lookup a contact in usrloc forcing DB and rewrite R-URI if found
+ * ( error if usrloc in NO_DB mode)
+ */
+int lookup_db(struct sip_msg* _m, udomain_t* _d, str* _uri);
+
+/*! \brief
  * Lookup r-uri and additional branches in usrloc
  */
 int lookup_branches(sip_msg_t *msg, udomain_t *d);
--- a/modules/registrar/reg_mod.c
+++ b/modules/registrar/reg_mod.c
@@ -90,7 +90,7 @@
 static void mod_destroy(void);
 static int w_save2(struct sip_msg* _m, char* _d, char* _cflags);
 static int w_save3(struct sip_msg* _m, char* _d, char* _cflags, char* _uri);
-static int w_lookup(struct sip_msg* _m, char* _d, char* _p2);
+static int w_lookup(struct sip_msg* _m, char* _d, char* _p2, char* _dbflag);
 static int w_lookup_branches(struct sip_msg* _m, char* _d, char* _p2);
 static int w_registered(struct sip_msg* _m, char* _d, char* _uri);
 static int w_unregister(struct sip_msg* _m, char* _d, char* _uri);
@@ -180,6 +180,8 @@
 			REQUEST_ROUTE | FAILURE_ROUTE },
 	{"lookup",       (cmd_function)w_lookup,      2,  domain_uri_fixup, 0,
 			REQUEST_ROUTE | FAILURE_ROUTE },
+	{"lookup",       (cmd_function)w_lookup,      3,  domain_uri_fixup, 0,
+			REQUEST_ROUTE | FAILURE_ROUTE },
 	{"registered",   (cmd_function)w_registered,  1,  domain_uri_fixup, 0,
 			REQUEST_ROUTE | FAILURE_ROUTE },
 	{"registered",   (cmd_function)w_registered,  2,  domain_uri_fixup, 0,
@@ -470,16 +472,23 @@
 /*! \brief
  * Wrapper to lookup(location)
  */
-static int w_lookup(struct sip_msg* _m, char* _d, char* _uri)
+static int w_lookup(struct sip_msg* _m, char* _d, char* _uri, char* _dbflag)
 {
-	str uri = {0};
+	str uri = STR_NULL;
+	unsigned int dbflag = 0;
 	if(_uri!=NULL && (fixup_get_svalue(_m, (gparam_p)_uri, &uri)!=0 || uri.len<=0))
 	{
 		LM_ERR("invalid uri parameter\n");
 		return -1;
 	}
-
-	return lookup(_m, (udomain_t*)_d, (uri.len>0)?&uri:NULL);
+	if(_dbflag!=NULL)
+	{
+		dbflag = (unsigned long)_dbflag;
+	}
+	if(dbflag)
+		return lookup_db(_m, (udomain_t*)_d, (uri.len>0)?&uri:NULL);
+	else
+		return lookup(_m, (udomain_t*)_d, (uri.len>0)?&uri:NULL);
 }
 
 /*! \brief
@@ -556,10 +565,23 @@
  */
 static int domain_uri_fixup(void** param, int param_no)
 {
+	unsigned int flags;
+	str s;
+
 	if (param_no == 1) {
 		return domain_fixup(param, 1);
 	} else if (param_no == 2) {
 		return fixup_spve_null(param, 1);
+	} else if (param_no == 3) {
+		flags = 0;
+		s.s = (char*)*param;
+		s.len = strlen(s.s);
+		if ( (str2int(&s, &flags )<0) ) {
+			LM_ERR("bad dbflags <%s>\n", (char *)(*param));
+			return E_CFG;
+		}
+		pkg_free(*param);
+		*param = (void*)(unsigned long)flags;
 	}
 	return 0;
 }
--- a/modules/usrloc/udomain.c
+++ b/modules/usrloc/udomain.c
@@ -993,14 +993,16 @@
  * \param _d domain to search the record
  * \param _aor address of record
  * \param _r new created record
+ * \param _dbflag force read from DB
  * \return 0 if a record was found, 1 if nothing could be found
  */
-int get_urecord(udomain_t* _d, str* _aor, struct urecord** _r)
+int _get_urecord(udomain_t* _d, str* _aor, struct urecord** _r,
+	unsigned int _dbflag)
 {
 	unsigned int sl, i, aorhash;
 	urecord_t* r;
 
-	if (db_mode!=DB_ONLY) {
+	if (db_mode!=DB_ONLY && !_dbflag) {
 		/* search in cache */
 		aorhash = ul_get_aorhash(_aor);
 		sl = aorhash&(_d->size-1);
@@ -1034,10 +1036,12 @@
  * \param _ruid record internal unique id
  * \param _r store pointer to location record
  * \param _c store pointer to contact structure
+ * \param _dbflag force read from DB
  * \return 0 if a record was found, -1 if nothing could be found
  */
-int get_urecord_by_ruid(udomain_t* _d, unsigned int _aorhash,
-		str *_ruid, struct urecord** _r, struct ucontact** _c)
+int _get_urecord_by_ruid(udomain_t* _d, unsigned int _aorhash,
+		str *_ruid, struct urecord** _r, struct ucontact** _c,
+		unsigned int _dbflag)
 {
 	unsigned int sl, i;
 	urecord_t* r;
@@ -1046,7 +1050,7 @@
 	sl = _aorhash&(_d->size-1);
 	lock_ulslot(_d, sl);
 
-	if (db_mode!=DB_ONLY) {
+	if (db_mode!=DB_ONLY && !_dbflag) {
 		/* search in cache */
 		r = _d->table[sl].first;
 
@@ -1089,6 +1093,71 @@
 }
 
 /*!
+ * \brief Obtain a urecord pointer if the urecord exists in domain
+ * \param _d domain to search the record
+ * \param _aor address of record
+ * \param _r new created record
+ * \return 0 if a record was found, 1 if nothing could be found
+ */
+int get_urecord(udomain_t* _d, str* _aor, struct urecord** _r)
+{
+	return _get_urecord(_d, _aor, _r, 0);
+}
+
+/*!
+ * \brief Obtain a urecord pointer if the urecord exists in domain (lock slot)
+ * \param _d domain to search the record
+ * \param _aorhash hash id for address of record
+ * \param _ruid record internal unique id
+ * \param _r store pointer to location record
+ * \param _c store pointer to contact structure
+ * \return 0 if a record was found, -1 if nothing could be found
+ */
+int get_urecord_by_ruid(udomain_t* _d, unsigned int _aorhash,
+		str *_ruid, struct urecord** _r, struct ucontact** _c) {
+	return _get_urecord_by_ruid(_d, _aorhash, _ruid, _r, _c, 0);
+}
+
+/*!
+ * \brief Obtain a urecord pointer if the urecord exists in domain
+ * this will force the load from DB ( error if NO_DB mode)
+ * \param _d domain to search the record
+ * \param _aor address of record
+ * \param _r new created record
+ * \return 0 if a record was found, 1 if nothing could be found
+ */
+int get_urecord_db(udomain_t* _d, str* _aor, struct urecord** _r)
+{
+	if(db_mode==NO_DB)
+	{
+		LM_ERR("db_mode is NO_DB\n");
+		return -1;
+	}
+	return _get_urecord(_d, _aor, _r, 1);
+}
+
+/*!
+ * \brief Obtain a urecord pointer if the urecord exists in domain (lock slot)
+ * this will force the load from DB ( error if NO_DB mode)
+ * \param _d domain to search the record
+ * \param _aorhash hash id for address of record
+ * \param _ruid record internal unique id
+ * \param _r store pointer to location record
+ * \param _c store pointer to contact structure
+ * \return 0 if a record was found, -1 if nothing could be found
+ */
+int get_urecord_by_ruid_db(udomain_t* _d, unsigned int _aorhash,
+		str *_ruid, struct urecord** _r, struct ucontact** _c)
+{
+	if(db_mode==NO_DB)
+	{
+		LM_ERR("db_mode is NO_DB\n");
+		return -1;
+	}
+	return _get_urecord_by_ruid(_d, _aorhash, _ruid, _r, _c, 1);
+}
+
+/*!
  * \brief Delete a urecord from domain
  * \param _d domain where the record should be deleted
  * \param _aor address of record
--- a/modules/usrloc/udomain.h
+++ b/modules/usrloc/udomain.h
@@ -204,6 +204,29 @@
 		str *_ruid, struct urecord** _r, struct ucontact** _c);
 
 /*!
+ * \brief Obtain a urecord pointer if the urecord exists in domain
+ * this will force the load from DB ( error if NO_DB mode)
+ * \param _d domain to search the record
+ * \param _aor address of record
+ * \param _r new created record
+ * \return 0 if a record was found, 1 if nothing could be found
+ */
+int get_urecord_db(udomain_t* _d, str* _aor, struct urecord** _r);
+
+/*!
+ * \brief Obtain a urecord pointer if the urecord exists in domain (lock slot)
+ * this will force the load from DB ( error if NO_DB mode)
+ * \param _d domain to search the record
+ * \param _aorhash hash id for address of record
+ * \param _ruid record internal unique id
+ * \param _r store pointer to location record
+ * \param _c store pointer to contact structure
+ * \return 0 if a record was found, 1 if nothing could be found
+ */
+int get_urecord_by_ruid_db(udomain_t* _d, unsigned int _aorhash,
+		str *_ruid, struct urecord** _r, struct ucontact** _c);
+
+/*!
  * \brief Delete a urecord from domain
  * \param _d domain where the record should be deleted
  * \param _aor address of record
--- a/modules/usrloc/usrloc.c
+++ b/modules/usrloc/usrloc.c
@@ -87,6 +87,9 @@
 	api->db_mode    = db_mode;
 	api->nat_flag   = nat_bflag;
 
+	api->get_urecord_by_ruid = get_urecord_by_ruid_db;
+	api->get_urecord_db      = get_urecord_db;
+
 	return 0;
 }
 
--- a/modules/usrloc/usrloc.h
+++ b/modules/usrloc/usrloc.h
@@ -153,6 +153,11 @@
 typedef int (*get_urecord_by_ruid_t)(udomain_t* _d, unsigned int _aorhash,
 		str *_ruid, struct urecord** _r, struct ucontact** _c);
 
+typedef int (*get_urecord_db_t)(struct udomain* _d, str* _aor, struct urecord** _r);
+
+typedef int (*get_urecord_by_ruid_db_t)(udomain_t* _d, unsigned int _aorhash,
+		str *_ruid, struct urecord** _r, struct ucontact** _c);
+
 typedef int  (*delete_urecord_t)(struct udomain* _d, str* _aor, struct urecord* _r);
 
 typedef int  (*delete_urecord_by_ruid_t)(struct udomain* _d, str* _ruid);
@@ -211,6 +216,7 @@
 	delete_urecord_t     delete_urecord;
 	delete_urecord_by_ruid_t     delete_urecord_by_ruid;
 	get_urecord_t        get_urecord;
+	get_urecord_db_t        get_urecord_db;
 	lock_udomain_t       lock_udomain;
 	unlock_udomain_t     unlock_udomain;
 
@@ -220,6 +226,7 @@
 	get_ucontact_t       get_ucontact;
 
 	get_urecord_by_ruid_t       get_urecord_by_ruid;
+	get_urecord_by_ruid_db_t       get_urecord_by_ruid_db;
 	get_ucontact_by_instance_t  get_ucontact_by_instance;
 
 	update_ucontact_t    update_ucontact;
