From 6041a6049cd398cf773cd9c63872282302acff6c Mon Sep 17 00:00:00 2001
From: Victor Seva <linuxmaniac@torreviejawireless.org>
Date: Sat, 24 May 2014 23:54:50 +0200
Subject: [PATCH] debugger: cfgtest. WIP.

---
 modules/debugger/Makefile       |   1 +
 modules/debugger/debugger_api.c | 504 +++++++++++++++++++++++++++++++++++++++-
 modules/debugger/debugger_api.h |   3 +
 modules/debugger/debugger_mod.c |  17 ++
 4 files changed, 517 insertions(+), 8 deletions(-)

diff --git a/modules/debugger/Makefile b/modules/debugger/Makefile
index a87111c..f76f588 100644
--- a/modules/debugger/Makefile
+++ b/modules/debugger/Makefile
@@ -11,4 +11,5 @@ DEFS+=-DKAMAILIO_MOD_INTERFACE
 
 SERLIBPATH=../../lib
 SER_LIBS+=$(SERLIBPATH)/srutils/srutils
+SER_LIBS+=$(SERLIBPATH)/kcore/kcore
 include ../../Makefile.modules
diff --git a/modules/debugger/debugger_api.c b/modules/debugger/debugger_api.c
index 9655491..25b66ec 100644
--- a/modules/debugger/debugger_api.c
+++ b/modules/debugger/debugger_api.c
@@ -41,6 +41,7 @@
 #include "../../lib/srutils/srjson.h"
 #include "../../xavp.h"
 #include "../pv/pv_xavp.h"
+#include "../../lib/kcore/cmpapi.h"
 
 #include "debugger_act.h"
 #include "debugger_api.h"
@@ -76,6 +77,7 @@ str *dbg_get_state_name(int t)
 #define DBG_CFGTRACE_ON	(1<<0)
 #define DBG_ABKPOINT_ON	(1<<1)
 #define DBG_LBKPOINT_ON	(1<<2)
+#define DBG_CFGTEST_ON	(1<<3)
 
 static str _dbg_status_list[] = {
 	str_init("cfgtrace-on"),
@@ -84,6 +86,8 @@ static str _dbg_status_list[] = {
 	str_init("abkpoint-off"),
 	str_init("lbkpoint-on"),
 	str_init("lbkpoint-off"),
+	str_init("cfgtest-on"),
+	str_init("cfgtest-off"),
 	{0, 0}
 };
 
@@ -95,6 +99,8 @@ str *dbg_get_status_name(int t)
 		return &_dbg_status_list[2];
 	if(t&DBG_LBKPOINT_ON)
 		return &_dbg_status_list[4];
+	if(t&DBG_CFGTEST_ON)
+		return &_dbg_status_list[6];
 
 	return &_dbg_state_list[0];
 }
@@ -195,6 +201,36 @@ int _dbg_step_loops = 200;
 int _dbg_reset_msgid = 0;
 
 /**
+ * disabled by default
+ */
+int _dbg_cfgtest = 0;
+
+typedef struct _dbg_cfgt_node
+{
+	srjson_doc_t jdoc;
+	str uuid;
+	int msgid;
+	str route;
+	srjson_t *in, *out, *flow;
+	struct _dbg_cfgt_node *next, *prev;
+} dbg_cfgt_node_t, *dbg_cfgt_node_p;
+/** TODO **/
+dbg_cfgt_node_p _dbg_cfgt_head = NULL;
+str _dbg_cfgt_basedir = {"/tmp/",5};
+str _dbg_cfgt_avp_param = {"$avp(s:route_name)", 18};
+pv_elem_p _dbg_cfgt_elem = NULL;
+
+/** defined later */
+int dbg_cfgt_filter(struct sip_msg *msg, unsigned int flags, void *bar);
+int dbg_cfgt_msgin(void *data);
+int dbg_cfgt_msgout(void *data);
+int _dbg_cfgt_create_node(struct sip_msg *msg);
+int _dbg_cfgt_get_hdr(struct sip_msg *msg, str *res);
+int _dbg_cfgt_cmp_hdr(struct sip_msg *msg, str *res);
+int _dbg_cfgt_save(str *uuid);
+int _dbg_cfgt_set_dump(struct sip_msg *msg);
+
+/**
  *
  */
 typedef struct _dbg_cmd
@@ -217,6 +253,8 @@ typedef struct _dbg_pid
 	gen_lock_t *lock;
 	unsigned int reset_msgid; /* flag to reset the id */
 	unsigned int msgid_base; /* real id since the reset */
+	unsigned int cfgt_save; /* flag to reset the id */
+	dbg_cfgt_node_p cfgt_node;
 } dbg_pid_t;
 
 /**
@@ -301,6 +339,9 @@ int dbg_cfg_trace(void *data)
     pv_value_t val;
 	void **srevp;
 	str *an;
+	dbg_cfgt_node_p node;
+	str route = STR_NULL;
+	str route_null = {"<null>", 6};
 
 	srevp = (void**)data;
 
@@ -334,6 +375,48 @@ int dbg_cfg_trace(void *data)
 				);
 		}
 	}
+	if(_dbg_pid_list[process_no].set&DBG_CFGTEST_ON)
+	{
+		node = _dbg_pid_list[process_no].cfgt_node;
+		if(!node)
+		{
+			LM_ERR("msgnode empty\n");
+		}
+		else
+		{
+			if(pv_printf_s(msg, _dbg_cfgt_elem, &route)<0)
+			{
+				LM_ERR("Cannot get route name by avp[%.*s]\n",
+					_dbg_cfgt_avp_param.len, _dbg_cfgt_avp_param.s);
+			}
+			else
+			{
+				if(STR_EQ(route, route_null)){
+					LM_ERR("Cannot get route name by avp[%.*s]\n",
+					_dbg_cfgt_avp_param.len, _dbg_cfgt_avp_param.s);
+				}
+				else if(!STR_EQ(route, node->route))
+				{
+					LM_DBG("Change to route[%.*s]. dump vars\n",
+						route.len, route.s);
+					if(node->route.s)
+					{
+						pkg_free(node->route.s);
+						node->route.len = 0;
+						node->route.s = NULL;
+					}
+					if(str_copy(&route, &node->route)<0)
+					{
+						LM_ERR("Cannot copy route name\n");
+					}
+					if(_dbg_cfgt_set_dump(msg)<0)
+					{
+						LM_ERR("Cannot get dump vars\n");
+					}
+				}
+			}
+		}
+	}
 	if(!(_dbg_pid_list[process_no].set&DBG_ABKPOINT_ON))
 	{
 		/* no breakpoints to be considered */
@@ -568,7 +651,10 @@ int dbg_init_mypid(void)
 		_dbg_pid_list[process_no].set |= DBG_ABKPOINT_ON;
 	if(_dbg_cfgtrace==1)
 		_dbg_pid_list[process_no].set |= DBG_CFGTRACE_ON;
-	if(_dbg_reset_msgid==1)
+	if(_dbg_cfgtest==1){
+		_dbg_pid_list[process_no].set |= DBG_CFGTEST_ON;
+	}
+	if(_dbg_reset_msgid==1||_dbg_cfgtest==1)
 	{
 		LM_DBG("[%d] create locks\n", process_no);
 		_dbg_pid_list[process_no].lock = lock_alloc();
@@ -999,12 +1085,46 @@ static void dbg_rpc_reset_msgid(rpc_t* rpc, void* ctx){
 /**
  *
  */
+static const char* dbg_rpc_cfgt_save_doc[2] = {
+	"Save cfgtest info to disk",
+	0
+};
+
+static void dbg_rpc_cfgt_save(rpc_t* rpc, void* ctx){
+	int i;
+	if (_dbg_cfgtest==0)
+	{
+		rpc->fault(ctx, 500, "cfgtest is 0. Set it to 1 to enable.");
+		return;
+	}
+	if(_dbg_pid_list==NULL)
+	{
+		rpc->fault(ctx, 500, "_dbg_pid_list is NULL");
+		return;
+	}
+	LM_DBG("set cfgt_save\n");
+	for(i=0; i<_dbg_pid_no; i++)
+	{
+		if (_dbg_pid_list[i].lock!=NULL)
+		{
+			lock_get(_dbg_pid_list[i].lock);
+			_dbg_pid_list[i].cfgt_save = 1;
+			lock_release(_dbg_pid_list[i].lock);
+		}
+	}
+	rpc->add(ctx, "s", "200 ok");
+}
+
+/**
+ *
+ */
 rpc_export_t dbg_rpc[] = {
 	{"dbg.bp",        dbg_rpc_bp,        dbg_rpc_bp_doc,        0},
 	{"dbg.ls",        dbg_rpc_list,      dbg_rpc_list_doc,      0},
 	{"dbg.trace",     dbg_rpc_trace,     dbg_rpc_trace_doc,     0},
 	{"dbg.mod_level", dbg_rpc_mod_level, dbg_rpc_mod_level_doc, 0},
 	{"dbg.reset_msgid", dbg_rpc_reset_msgid, dbg_rpc_reset_msgid_doc, 0},
+	{"dbg.cfgt_save", dbg_rpc_cfgt_save, dbg_rpc_cfgt_save_doc, 0},
 	{0, 0, 0, 0}
 };
 
@@ -1622,7 +1742,8 @@ int _dbg_get_obj_xavp_vals(struct sip_msg *msg,
 	return 0;
 }
 
-int _dbg_get_json(struct sip_msg* msg, unsigned int mask, srjson_doc_t *jdoc)
+int _dbg_get_json(struct sip_msg* msg, unsigned int mask,
+	srjson_doc_t *jdoc, srjson_t *head)
 {
 	int i;
 	pv_value_t value;
@@ -1637,8 +1758,8 @@ int _dbg_get_json(struct sip_msg* msg, unsigned int mask, srjson_doc_t *jdoc)
 		LM_ERR("cannot access pv_cache\n");
 		return -1;
 	}
-	if(jdoc==NULL){
-		LM_ERR("jdoc is null\n");
+	if(jdoc==NULL||head==NULL){
+		LM_ERR("jdoc or head is null\n");
 		return -1;
 	}
 
@@ -1748,7 +1869,7 @@ int _dbg_get_json(struct sip_msg* msg, unsigned int mask, srjson_doc_t *jdoc)
 			}
 			if(jobj!=NULL)
 			{
-				srjson_AddItemToObject(jdoc, jdoc->root, iname, jobj);
+				srjson_AddItemToObject(jdoc, head, iname, jobj);
 			}
 			el = el->next;
 		}
@@ -1756,7 +1877,7 @@ int _dbg_get_json(struct sip_msg* msg, unsigned int mask, srjson_doc_t *jdoc)
 	return 0;
 
 error:
-	srjson_DestroyDoc(jdoc);
+	srjson_Delete(jdoc, head);
 	return -1;
 }
 
@@ -1776,7 +1897,7 @@ int dbg_dump_json(struct sip_msg* msg, unsigned int mask, int level)
 		}
 	}
 
-	if(_dbg_get_json(msg, mask, &jdoc)<0) return -1;
+	if(_dbg_get_json(msg, mask, &jdoc, jdoc.root)<0) goto error;
 	output = srjson_PrintUnformatted(&jdoc, jdoc.root);
 	if(output==NULL)
 	{
@@ -1791,4 +1912,371 @@ int dbg_dump_json(struct sip_msg* msg, unsigned int mask, int level)
 error:
 	srjson_DestroyDoc(&jdoc);
 	return -1;
-}
\ No newline at end of file
+}
+
+int dbg_cfgt_msgin(void *data)
+{
+	dbg_cfgt_node_p node;
+	srjson_t *jobj;
+	str *buf = (str *) data;
+	if(buf==NULL) return 0;
+	LM_DBG("msg in:{%.*s}\n", buf->len, buf->s);
+	_dbg_cfgt_create_node(NULL);
+	node = _dbg_pid_list[process_no].cfgt_node;
+	if(node)
+	{
+		jobj = srjson_CreateStr(&node->jdoc, buf->s, buf->len);
+		if(jobj==NULL)
+		{
+			LM_ERR("cannot create json object\n");
+			return -1;
+		}
+		srjson_AddItemToArray(&node->jdoc, node->in, jobj);
+		return 0;
+	}
+	LM_ERR("node empty\n");
+	return -1;
+}
+
+int dbg_cfgt_filter(struct sip_msg *msg, unsigned int flags, void *bar)
+{
+	lock_get(_dbg_pid_list[process_no].lock);
+	if(_dbg_pid_list[process_no].cfgt_save==1)
+	{
+		LM_DBG("cfgt_save!\n");
+		_dbg_pid_list[process_no].cfgt_save = 0;
+	}
+	lock_release(_dbg_pid_list[process_no].lock);
+
+	dbg_cfgt_node_p node = _dbg_pid_list[process_no].cfgt_node;
+
+	if(node)
+	{
+		if (node->msgid == 0)
+		{
+			LM_DBG("new node\n");
+			node->msgid = msg->id;
+			LM_DBG("msgid:%d\n", node->msgid);
+			if(_dbg_cfgt_get_hdr(msg, &node->uuid)!=0)
+			{
+				LM_ERR("cannot get value of cfgtest uuid header!!\n");
+				return -1;
+			}
+			return 0;
+		}
+		else
+		{
+			LM_DBG("node->uuid:[%.*s]\n", node->uuid.len, node->uuid.s);
+			if(_dbg_cfgt_cmp_hdr(msg, &node->uuid))
+			{
+				LM_DBG("same uuid\n");
+				return 0;
+			}
+		}
+	}
+	else { LM_ERR("node empty\n"); }
+	return _dbg_cfgt_create_node(msg);
+}
+
+int dbg_cfgt_msgout(void *data)
+{
+	dbg_cfgt_node_p node;
+	srjson_t *jobj;
+	str *buf = (str *) data;
+	if(buf==NULL) return 0;
+	LM_DBG("msg out:{%.*s}\n", buf->len, buf->s);
+	node = _dbg_pid_list[process_no].cfgt_node;
+	if(node)
+	{
+		jobj = srjson_CreateStr(&node->jdoc, buf->s, buf->len);
+		if(jobj==NULL)
+		{
+			LM_ERR("cannot create json object\n");
+			return -1;
+		}
+		srjson_AddItemToArray(&node->jdoc, node->out, jobj);
+		return 0;
+	}
+	LM_ERR("msgnode empty\n");
+	return -1;
+}
+
+int dbg_init_cfgtest(void)
+{
+	if (_dbg_cfgt_avp_param.s && _dbg_cfgt_avp_param.len > 0)
+	{
+		if (pv_parse_format(&_dbg_cfgt_avp_param, &_dbg_cfgt_elem)<0)
+		{
+			LM_ERR("malformed or non AVP %.*s AVP definition\n",
+					_dbg_cfgt_avp_param.len, _dbg_cfgt_avp_param.s);
+			return -1;
+		}
+	}
+	sr_event_register_cb(SREV_NET_DATA_IN, dbg_cfgt_msgin);
+	sr_event_register_cb(SREV_NET_DATA_OUT, dbg_cfgt_msgout);
+	return 0;
+}
+
+int _dbg_cfgt_create_node(struct sip_msg *msg)
+{
+	dbg_cfgt_node_p node;
+
+	node = (dbg_cfgt_node_p) pkg_malloc(sizeof(dbg_cfgt_node_t));
+	if(node==NULL)
+	{
+		LM_ERR("cannot allocate cfgtest msgnode\n");
+		return -1;
+	}
+	memset(node, 0, sizeof(dbg_cfgt_node_t));
+	srjson_InitDoc(&node->jdoc, NULL);
+	if (msg)
+	{
+		node->msgid = msg->id;
+		LM_DBG("msgid:%d\n", node->msgid);
+		if(_dbg_cfgt_get_hdr(msg, &node->uuid)!=0)
+		{
+			LM_ERR("cannot get value of cfgtest uuid header!!\n");
+			goto error;
+		}
+	}
+	node->jdoc.root = srjson_CreateObject(&node->jdoc);
+	if(node->jdoc.root==NULL)
+	{
+		LM_ERR("cannot create json root\n");
+		goto error;
+	}
+	node->flow = srjson_CreateArray(&node->jdoc);
+	if(node->flow==NULL)
+	{
+		LM_ERR("cannot create json object\n");
+		goto error;
+	}
+	srjson_AddItemToObject(&node->jdoc, node->jdoc.root, "flow\0", node->flow);
+	node->in = srjson_CreateArray(&node->jdoc);
+	if(node->in==NULL)
+	{
+		LM_ERR("cannot create json object\n");
+		goto error;
+	}
+	srjson_AddItemToObject(&node->jdoc, node->jdoc.root, "in\0", node->in);
+	node->out = srjson_CreateArray(&node->jdoc);
+	if(node->out==NULL)
+	{
+		LM_ERR("cannot create json object\n");
+		goto error;
+	}
+	srjson_AddItemToObject(&node->jdoc, node->jdoc.root, "out\0", node->out);
+	LM_DBG("node created\n");
+	if(_dbg_cfgt_head)
+	{
+		clist_append(_dbg_cfgt_head, node, next, prev);
+	}
+	else
+	{
+		LM_DBG("Initial node\n");
+		clist_init(node, next, prev);
+	}
+	_dbg_pid_list[process_no].cfgt_node = node;
+	return 0;
+
+error:
+	srjson_DestroyDoc(&node->jdoc);
+	pkg_free(node);
+	_dbg_pid_list[process_no].cfgt_node = NULL;
+	return -1;
+}
+
+int _dbg_cfgt_get_hdr_helper(struct sip_msg *msg, str *res, int mode)
+{
+	str name = {"P-NGCP-CFGTEST", 14};
+	struct hdr_field *hf;
+
+	if(msg==NULL || (mode==0 && res==NULL))
+		return -1;
+
+	/* we need to be sure we have parsed all headers */
+	if(parse_headers(msg, HDR_EOH_F, 0)<0)
+	{
+		LM_ERR("error parsing headers\n");
+		return -1;
+	}
+
+	for (hf=msg->headers; hf; hf=hf->next)
+	{
+		if (cmp_hdrname_str(&hf->name, &name)==0)
+		{
+			if(mode==0)
+			{
+				if(str_copy(&hf->body, res)<0)
+				{
+					LM_ERR("error copying header\n");
+					return -1;
+				}
+				LM_DBG("cfgtest uuid:%.*s\n", res->len, res->s);
+				return 0;
+			}
+			else return STR_EQ(hf->body, *res);
+		}
+	}
+	return 1; /* not found */
+}
+
+int _dbg_cfgt_get_hdr(struct sip_msg *msg, str *res)
+{
+	return _dbg_cfgt_get_hdr_helper(msg, res, 0);
+}
+
+int _dbg_cfgt_cmp_hdr(struct sip_msg *msg, str *res)
+{
+	return _dbg_cfgt_get_hdr_helper(msg, res, 1);
+}
+
+int _dbg_cfgt_get_filename(int msgid, str uuid, str *dest)
+{
+	int i, lid, lnproc;
+	char buff_id[INT2STR_MAX_LEN], buff_nproc[INT2STR_MAX_LEN];
+	char *sid, *snproc;
+	if(dest==NULL || uuid.len == 0) return -1;
+	sid = sint2strbuf(msgid, buff_id, INT2STR_MAX_LEN, &lid);
+	snproc = sint2strbuf(process_no, buff_nproc, INT2STR_MAX_LEN, &lnproc);
+	dest->len = _dbg_cfgt_basedir.len + uuid.len + lid + lnproc + 8;
+	dest->s = (char *) pkg_malloc(dest->len*sizeof(char));
+	if(dest->s==NULL) return -1;
+	strncpy(dest->s, _dbg_cfgt_basedir.s, _dbg_cfgt_basedir.len);
+	i = _dbg_cfgt_basedir.len;
+	strncpy(dest->s+i, uuid.s, uuid.len);
+	i = i + uuid.len;
+	strncpy(dest->s+i, "/", 1);
+	i = i + 1;
+	strncpy(dest->s+i, snproc, lid);
+	i = i + lnproc;
+	strncpy(dest->s+i, "/", 1);
+	i = i + 1;
+	strncpy(dest->s+i, sid, lid);
+	i = i + lid;
+	strncpy(dest->s+i, ".json\0", 6);
+	return 0;
+}
+
+void _dbg_cfgt_remove_node(dbg_cfgt_node_p node)
+{
+	srjson_DestroyDoc(&node->jdoc);
+	if(node->uuid.s) pkg_free(node->uuid.s);
+	clist_rm(node, next, prev);
+	if(_dbg_pid_list[process_no].cfgt_node == node)
+	{
+		LM_DBG("cfgt_node deleted\n");
+		_dbg_pid_list[process_no].cfgt_node = NULL;
+	}
+	pkg_free(node);
+}
+
+int _dbg_cfgt_save_node(dbg_cfgt_node_p node)
+{
+	FILE *f = NULL;
+	str filename = STR_NULL;
+	char *buf = NULL;
+	size_t len;
+	int res = -1;
+
+	if (_dbg_cfgt_head==NULL) return -1;
+
+	LM_DBG("msgid:%d uuid:%.*s\n", node->msgid, node->uuid.len, node->uuid.s);
+	if(_dbg_cfgt_get_filename(node->msgid, node->uuid, &filename)<0)
+	{
+		LM_ERR("Cannot get filename\n");
+		res = -1;
+		goto clean;
+	}
+	f = fopen ( filename.s, "w");
+	if(f==NULL)
+	{
+		LM_ERR("Cannot open %.*s for write\n", filename.len, filename.s);
+		res = -1;
+		goto clean;
+	}
+	buf = srjson_PrintUnformatted(&node->jdoc, node->jdoc.root);
+	if(buf==NULL)
+	{
+		LM_ERR("Cannot get the json string\n");
+		fclose(f);
+		res = -1;
+		goto clean;
+	}
+	len = strlen(buf);
+	LM_DBG("buf size:%lu\n", len);
+	fwrite(buf, len, 1, f);
+	fclose(f);
+	res = 0;
+
+clean:
+	if(filename.s) pkg_free(filename.s);
+	if(buf) node->jdoc.free_fn(buf);
+	return res;
+}
+
+int _dbg_cfgt_save(str *uuid)
+{
+	int res = 0;
+	dbg_cfgt_node_p node, back;
+
+	if(_dbg_cfgt_head==NULL) return -1;
+	if(uuid)
+	{
+		clist_foreach_safe(_dbg_cfgt_head, node, back, next)
+		{
+			if(STR_EQ(node->uuid, *uuid))
+			{
+				if(_dbg_cfgt_save_node(node)<0)
+				{
+					LM_ERR("Cannot save node:%p\n", node);
+					res = res - 1;
+				}
+				_dbg_cfgt_remove_node(node);
+			}
+		}
+	}
+	else
+	{
+		clist_foreach_safe(_dbg_cfgt_head, node, back, next)
+		{
+			if(_dbg_cfgt_save_node(node)<0)
+			{
+				LM_ERR("Cannot save node:%p\n", node);
+				res = res - 1;
+			}
+			_dbg_cfgt_remove_node(node);
+		}
+	}
+	return res;
+}
+
+int _dbg_cfgt_set_dump(struct sip_msg *msg)
+{
+	srjson_t *f, *vars;
+	dbg_cfgt_node_p node = _dbg_pid_list[process_no].cfgt_node;
+
+	vars = srjson_CreateObject(&node->jdoc);
+	if(vars==NULL)
+	{
+		LM_ERR("cannot create json object\n");
+		return -1;
+	}
+	if(_dbg_get_json(msg, 30, &node->jdoc, vars)<0)
+	{
+		LM_ERR("cannot get var info\n");
+		return -1;
+	}
+	f = srjson_CreateObject(&node->jdoc);
+	if(f==NULL)
+	{
+		LM_ERR("cannot create json object\n");
+		srjson_Delete(&node->jdoc, vars);
+		return -1;
+	}
+	srjson_AddStrItemToObject(&node->jdoc, f,
+		node->route.s, node->route.len, vars);
+	srjson_AddItemToArray(&node->jdoc, node->flow, f);
+	LM_DBG("node[%.*s] flow created\n", node->route.len, node->route.s);
+	return 0;
+}
diff --git a/modules/debugger/debugger_api.h b/modules/debugger/debugger_api.h
index 011013a..856931a 100644
--- a/modules/debugger/debugger_api.h
+++ b/modules/debugger/debugger_api.h
@@ -57,5 +57,8 @@ int dbg_msgid_filter(struct sip_msg *msg, unsigned int flags, void *bar);
 #define DBG_DP_OTHER		16
 #define DBG_DP_ALL			31
 int dbg_dump_json(struct sip_msg* msg, unsigned int mask, int level);
+
+int dbg_init_cfgtest(void);
+int dbg_cfgt_filter(struct sip_msg *msg, unsigned int flags, void *bar);
 #endif
 
diff --git a/modules/debugger/debugger_mod.c b/modules/debugger/debugger_mod.c
index 8434dde..7e127fb 100644
--- a/modules/debugger/debugger_mod.c
+++ b/modules/debugger/debugger_mod.c
@@ -62,6 +62,8 @@ extern char *_dbg_cfgtrace_lname;
 extern int _dbg_step_usleep;
 extern int _dbg_step_loops;
 extern int _dbg_reset_msgid;
+extern int _dbg_cfgtest;
+extern str _dbg_cfgt_avp_param;
 
 static char * _dbg_cfgtrace_facility_str = 0;
 static int _dbg_log_assign = 0;
@@ -93,6 +95,8 @@ static param_export_t params[]={
 	{"mod_level",         STR_PARAM|USE_FUNC_PARAM, (void*)dbg_mod_level_param},
 	{"reset_msgid",       INT_PARAM, &_dbg_reset_msgid},
 	{"cfgpkgcheck",       INT_PARAM, &_dbg_cfgpkgcheck},
+	{"cfgtest",           INT_PARAM, &_dbg_cfgtest},
+	{"cfgt_avp",          STR_PARAM, &_dbg_cfgt_avp_param.s},
 	{0, 0, 0}
 };
 
@@ -168,6 +172,19 @@ static int mod_init(void)
 			return -1;
 		}
 	}
+	if(_dbg_cfgtest==1)
+	{
+		unsigned int ALL = REQUEST_CB+FAILURE_CB+ONREPLY_CB
+		  +BRANCH_CB+ONSEND_CB+ERROR_CB+LOCAL_CB+EVENT_CB+BRANCH_FAILURE_CB;
+		if (register_script_cb(dbg_cfgt_filter, PRE_SCRIPT_CB|ALL, 0) != 0)
+		{
+			LM_ERR("could not insert callback");
+			return -1;
+		}
+		if (_dbg_cfgt_avp_param.s)
+			_dbg_cfgt_avp_param.len = strlen(_dbg_cfgt_avp_param.s);
+		dbg_init_cfgtest();
+	}
 	return dbg_init_bp_list();
 }
 
-- 
2.0.0.rc2

