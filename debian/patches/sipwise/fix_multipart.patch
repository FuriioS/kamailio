--- a/msg_translator.c
+++ b/msg_translator.c
@@ -148,6 +148,7 @@
 #include "cfg/cfg.h"
 #include "parser/parse_to.h"
 #include "parser/parse_param.h"
+#include "parser/sdp/sdp_helpr_funcs.h"
 #include "forward.h"
 #include "str_list.h"
 
@@ -1725,46 +1726,27 @@
  */
 int get_boundary(struct sip_msg* msg, str* boundary)
 {
-	str params;
-	param_t *p, *list;
-	param_hooks_t hooks;
-
-	params.s = memchr(msg->content_type->body.s, ';',
-		msg->content_type->body.len);
-	if (params.s == NULL)
-	{
-		LM_ERR("Content-Type hdr has no params\n");
-		return -1;
-	}
-	params.len = msg->content_type->body.len -
-		(params.s - msg->content_type->body.s);
-	if (parse_params(&params, CLASS_ANY, &hooks, &list) < 0)
-	{
-		LM_ERR("while parsing Content-Type params\n");
+	str mpdel = {0,0};
+
+	/* multipart body */
+	if(get_mixed_part_delimiter(&msg->content_type->body,&mpdel) < 0) {
+		LM_ERR("no boundary found\n");
 		return -1;
 	}
+	LM_DBG("delimiter is <%.*s>\n", mpdel.len, mpdel.s);
 	boundary->s = NULL;
 	boundary->len = 0;
-	for (p = list; p; p = p->next) {
-		if ((p->name.len == 8)
-			&& (strncasecmp(p->name.s, "boundary", 8) == 0))
-		{
-			boundary->s = pkg_malloc(p->body.len + 2);
-			if (boundary->s == NULL)
-			{
-				free_params(list);
-				LM_ERR("no memory for boundary string\n");
-				return -1;
-			}
-			*(boundary->s) = '-';
-			*(boundary->s + 1) = '-';
-			memcpy(boundary->s + 2, p->body.s, p->body.len);
-			boundary->len = 2 + p->body.len;
-			LM_DBG("boundary is <%.*s>\n", boundary->len, boundary->s);
-			break;
-		}
+	boundary->s = pkg_malloc(mpdel.len + 2);
+	if (boundary->s == NULL)
+	{
+		LM_ERR("no memory for boundary string\n");
+		return -1;
 	}
-	free_params(list);
+	*(boundary->s) = '-';
+	*(boundary->s + 1) = '-';
+	memcpy(boundary->s + 2, mpdel.s, mpdel.len);
+	boundary->len = 2 + mpdel.len;
+	LM_DBG("boundary is <%.*s>\n", boundary->len, boundary->s);
 	return 0;
 }
 
@@ -1888,8 +1870,8 @@
 			body.len = body.len + lb->s.len;
 			/*LM_DBG("copy[%d][%.*s]\n", lb->s.len, lb->s.len, pb - lb->s.len);*/
 		}
-		/*LM_DBG("body[%d][%.*s] expected[%ld]\n",
-			body.len, body.len, body.s, pb-body.s); */
+		LM_DBG("body[%d][%.*s] expected[%ld]\n",
+			body.len, body.len, body.s, pb-body.s);
 		if(!replace_body(msg, body))
 		{
 			LM_ERR("Can't replace body\n");
--- a/modules/textops/textops.c
+++ b/modules/textops/textops.c
@@ -1455,8 +1455,8 @@
 	return 1;
 }
 
-static str* generate_boundary(str txt, str content_type,
-	str content_disposition, str delimiter, unsigned int initial)
+static str* generate_boundary(str *txt, str *content_type,
+	str *content_disposition, str *delimiter, unsigned int initial)
 {
 	unsigned int i = 0;
 	str cth = {"Content-Type: ", 14};
@@ -1464,7 +1464,9 @@
 	str* n;
 	unsigned int flag = 0;
 
-	if(txt.len==0||content_type.len==0||delimiter.len==0)
+	if(txt==NULL||txt->len==0
+		||content_type==NULL||content_type->len==0
+		||delimiter==NULL||delimiter->len==0)
 	{
 		LM_ERR("invalid parameters\n");
 		return NULL;
@@ -1475,21 +1477,25 @@
 		LM_ERR("out of pkg memory\n");
 		return NULL;
 	}
-	n->len = delimiter.len + 2 + CRLF_LEN;
+	n->len = delimiter->len + 2 + CRLF_LEN;
 	if(initial) n->len = 2*n->len;
-	if(strncmp("\r\n\r\n", txt.s+txt.len-4,4)!=0)
+	if(strncmp("\r\n\r\n", txt->s+txt->len-4,4)!=0)
 	{
 		n->len = n->len + CRLF_LEN;
 		flag = 1;
 		LM_DBG("adding final CRLF+CRLF\n");
 	}
-	n->len=n->len + cth.len + content_type.len + 2*CRLF_LEN;
-	if(content_disposition.len>0)
+	n->len=n->len + cth.len + content_type->len + 2*CRLF_LEN;
+	if(content_disposition->len>0)
 	{
-		n->len = n->len + cdh.len + content_disposition.len + CRLF_LEN;
+		n->len = n->len + cdh.len + content_disposition->len + CRLF_LEN;
 	}
-	n->len = n->len + txt.len;
-
+	n->len = n->len + txt->len;
+	LM_DBG("n<%d> txt<%d>[%.*s] content_type<%d>[%.*s] content_disposition<%d>[%.*s]\n",
+		n->len,
+		txt->len, txt->len, txt->s,
+		content_type->len, content_type->len, content_type->s,
+		content_disposition->len, content_disposition->len, content_disposition->s);
 	n->s = pkg_malloc(sizeof(char)*(n->len));
 	if(n->s==0)
 	{
@@ -1497,31 +1503,32 @@
 		pkg_free(n);
 		return NULL;
 	}
+	memset(n->s, 0, sizeof(char)*n->len);
 	if(initial)
 	{
 		memcpy(n->s, "--", 2); i=2;
-		memcpy(n->s+i, delimiter.s, delimiter.len); i=i+delimiter.len;
+		memcpy(n->s+i, delimiter->s, delimiter->len); i=i+delimiter->len;
 		memcpy(n->s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
 	}
 
 	memcpy(n->s+i, cth.s, cth.len); i=i+cth.len;
-	memcpy(n->s+i, content_type.s, content_type.len); i=i+content_type.len;
+	memcpy(n->s+i, content_type->s, content_type->len); i=i+content_type->len;
 	memcpy(n->s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
 
-	if(content_disposition.len>0)
+	if(content_disposition->len>0)
 	{
 		memcpy(n->s+i, cdh.s, cdh.len); i=i+cdh.len;
-		memcpy(n->s+i, content_disposition.s, content_disposition.len);
-		i=i+content_disposition.len;
+		memcpy(n->s+i, content_disposition->s, content_disposition->len);
+		i=i+content_disposition->len;
 		memcpy(n->s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
 	}
 	memcpy(n->s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
 
-	memcpy(n->s+i, txt.s, txt.len); i=i+txt.len;
+	memcpy(n->s+i, txt->s, txt->len); i=i+txt->len;
 	if(flag) { memcpy(n->s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN; }
 
 	memcpy(n->s+i, "--", 2); i=i+2;
-	memcpy(n->s+i, delimiter.s, delimiter.len); i=i+delimiter.len;
+	memcpy(n->s+i, delimiter->s, delimiter->len); i=i+delimiter->len;
 	memcpy(n->s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
 
 	if(i!=n->len)
@@ -1668,7 +1675,7 @@
 	}
 
 	/* get initial boundary */
-	nbb = generate_boundary(nb, oc, cd, delimiter, 1);
+	nbb = generate_boundary(&nb, &oc, &cd, &delimiter, 1);
 	if(nbb==NULL)
 	{
 		LM_ERR("couldn't create initial boundary\n");
@@ -1862,7 +1869,7 @@
 		LM_ERR("Cannot get boundary. Is body multipart?\n");
 		return -1;
 	}
-	nbb = generate_boundary(txt, nc, cd, delimiter, 0);
+	nbb = generate_boundary(&txt, &nc, &cd, &delimiter, 0);
 	if(nbb==NULL)
 	{
 		LM_ERR("couldn't create initial boundary\n");
@@ -1870,6 +1877,7 @@
 		return -1;
 	}
 	pkg_free(delimiter.s);
+	LM_DBG("nbb<%d>[%.*s]\n", nbb->len ,nbb->len, nbb->s);
 	if(insert_new_lump_after(l, nbb->s, nbb->len, 0)==0){
 		LM_ERR("could not insert new lump\n");
 		pkg_free(nbb->s); pkg_free(nbb);
@@ -1881,6 +1889,7 @@
 		LM_DBG("set flag FL_BODY_MULTIPART\n");
 		msg->msg_flags |= FL_BODY_MULTIPART;
 	}
+	LM_DBG("done\n");
 	return 1;
 }
 
