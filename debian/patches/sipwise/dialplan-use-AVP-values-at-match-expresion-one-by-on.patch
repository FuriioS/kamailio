From 90f3239670ace8ed8e2e4b8b00ba2c3ecad559ec Mon Sep 17 00:00:00 2001
From: Victor Seva <linuxmaniac@torreviejawireless.org>
Date: Sat, 28 Jun 2014 12:37:10 +0200
Subject: [PATCH] dialplan: use AVP[*] values at match expresion one by one.

---
 modules/dialplan/dialplan.h |  15 ++-
 modules/dialplan/dp_db.c    |  72 +++++++++++++--
 modules/dialplan/dp_repl.c  | 218 +++++++++++++++++++++++++++++++++++++++-----
 3 files changed, 272 insertions(+), 33 deletions(-)

--- a/modules/dialplan/dialplan.h
+++ b/modules/dialplan/dialplan.h
@@ -48,8 +48,9 @@
 #define DP_PV_MATCH_M	(1 << 1) /* PV_MARKER at the end */
 #define DP_PV_SUBST		(1 << 2)
 #define DP_PV_SUBST_M	(1 << 3) /* PV_MARKER at the end */
+#define DP_PV_MATCH_AVP (1 << 4) /* AVP WITH AVP_INDEX_ALL */
 
-#define DP_PV_MASK (DP_PV_MATCH|DP_PV_SUBST)
+#define DP_PV_MASK (DP_PV_MATCH|DP_PV_SUBST|DP_PV_MATCH_AVP)
 #define DP_PV_MATCH_MASK (DP_PV_MATCH|DP_PV_MATCH_M)
 #define DP_PV_SUBST_MASK (DP_PV_SUBST|DP_PV_SUBST_M)
 
@@ -85,10 +86,18 @@
 	struct dpl_id * next;
 }dpl_id_t,*dpl_id_p;
 
+typedef struct dpl_pv_match_node
+{
+	pcre *comp;
+	str expr;
+	struct dpl_pv_match_node *next;
+}dpl_pv_match_node_t, *dpl_pv_match_node_p;
+
 typedef struct dpl_pv_node{
 	pv_elem_p match_elem, subst_elem;
-	str match_exp, subst_exp; /* exp without end dollar char */
-	pcre *match_comp, *subst_comp; /* compiled patterns */
+	str subst_exp; /* exp without end dollar char */
+	pcre *subst_comp; /* compiled patterns */
+	dpl_pv_match_node_p match_comp; /* list of match regex compiled */
 
 	struct dpl_pv_node * next; /* next rule */
 	struct dpl_node * orig; /* shared rule */
--- a/modules/dialplan/dp_db.c
+++ b/modules/dialplan/dp_db.c
@@ -395,10 +395,40 @@
 	}
 }
 
+int set_pv_match_avp_flag(pv_elem_p elem, unsigned int *pv_flags)
+{
+	int num, num_elem;
+	pv_elem_p e;
+	pv_spec_p spec, spec_check = NULL;
+	if(elem==NULL||pv_flags==NULL) return -1;
+
+	e = elem;
+	if (e==NULL) return -1;
+	spec = e->spec;
+	if (spec==NULL) return -1;
+
+	for(e=elem, num=num_elem=0; e!=NULL; e=e->next, num++)
+	{
+		spec = e->spec;
+		LM_DBG("elem[%d][%p][%.*s][%p]\n", num, e, e->text.len, e->text.s, spec);
+		if(spec!=NULL) num_elem++;
+		if(spec_check==NULL) spec_check = spec;
+	}
+
+	if(num_elem==1 && spec_check->type==PVT_AVP &&
+		spec_check->pvp.pvi.type==PV_IDX_ALL)
+	{
+		*pv_flags |= DP_PV_MATCH_AVP;
+		*pv_flags &= ~DP_PV_MATCH;
+		return 0;
+	}
+	return 1;
+}
+
 dpl_pv_node_t * build_pv_rule(dpl_node_t *rule)
 {
 	pv_elem_p match_elem = NULL, subst_elem = NULL;
-	str match_exp = {NULL,0}, subst_exp = {NULL,0};
+	str match_exp = STR_NULL, subst_exp = STR_NULL;
 	dpl_pv_node_t * new_rule = NULL;
 
 	if(!rule)
@@ -416,6 +446,18 @@
 				match_exp.len, match_exp.s);
 			goto err;
 		}
+		LM_DBG("match_exp:%.*s\n", match_exp.len, match_exp.s);
+		switch(set_pv_match_avp_flag(match_elem, &rule->pv_flags))
+		{
+			case 0:
+				LM_DBG("DP_PV_MATCH_AVP detected\n");
+				break;
+			case 1:
+				break;
+			default:
+				LM_ERR("detecting AVP\n");
+				goto err;
+		}
 	}
 
 	if(rule->pv_flags&DP_PV_SUBST)
@@ -439,13 +481,14 @@
 			goto err;
 		}
 		memset(new_rule, 0, sizeof(dpl_pv_node_t));
-		if(rule->pv_flags&DP_PV_MATCH) {
+		if(rule->pv_flags&DP_PV_MATCH || rule->pv_flags&DP_PV_MATCH_AVP) {
 			new_rule->match_elem = match_elem;
 		}
 		if(rule->pv_flags&DP_PV_SUBST) {
 			new_rule->subst_elem = subst_elem;
 		}
 		new_rule->orig = rule;
+		list_pv_rule(new_rule);
 	}
 	return new_rule;
 
@@ -883,13 +926,19 @@
 }
 
 void destroy_pv_rule(dpl_pv_node_t * rule){
+	dpl_pv_match_node_p n;
+
 	if(!rule)
 		return;
 
 	LM_DBG("destroying pv_rule %i\n", rule->orig->dpid);
-	if(rule->match_comp){
-		pcre_free(rule->match_comp);
-		rule->match_comp = NULL;
+	while(rule->match_comp)
+	{
+		n = rule->match_comp;
+		if(n->comp) pcre_free(n->comp);
+		if(n->expr.s) pkg_free(n->expr.s);
+		rule->match_comp = n->next;
+		pkg_free(n);
 	}
 	if(rule->subst_comp){
 		pcre_free(rule->subst_comp);
@@ -1028,10 +1077,15 @@
 
 void list_pv_rule(dpl_pv_node_t * rule)
 {
-	LM_DBG("PV_RULE %p: next %p match_exp %.*s, "
-			"subst_exp %.*s \n", rule, rule->next,
-			rule->match_exp.len, rule->match_exp.s,
-			rule->subst_exp.len, rule->subst_exp.s);
+	int num = 0;
+	dpl_pv_match_node_p n = rule->match_comp;
+	LM_DBG("PV_RULE %p: next %p subst_exp %.*s \n",
+			rule, rule->next, rule->subst_exp.len, rule->subst_exp.s);
+	while(n)
+	{
+		LM_DBG("match[%d] expr:%.*s\n", num, n->expr.len, n->expr.s);
+		num++;
+	}
 }
 
 void show_pv_flags(unsigned int flag)
@@ -1042,6 +1096,7 @@
 	if(flag&DP_PV_SUBST) LM_DBG("DP_PV_SUBST\n");
 	if(flag&DP_PV_SUBST_M) LM_DBG("DP_PV_SUBST_M\n");
 	if(flag&DP_PV_SUBST_MASK) LM_DBG("DP_PV_SUBST_MASK\n");
+	if(flag&DP_PV_MATCH_AVP) LM_DBG("DP_PV_MATCH_AVP\n");
 	if(flag&DP_PV_MASK) LM_DBG("DP_PV_MASK\n");
 	LM_DBG("--pv_flags:%d\n", flag);
 }
--- a/modules/dialplan/dp_repl.c
+++ b/modules/dialplan/dp_repl.c
@@ -159,7 +159,11 @@
 		subst_exp = rule->subst_exp;
 	}
 	if(rule_pv&&(rule_pv->orig->pv_flags&DP_PV_MATCH)){
-		match_exp = rule_pv->match_exp;
+		if(rule_pv->match_comp)
+		{
+			match_exp = rule_pv->match_comp->expr;
+		}
+		else return -1;
 	}
 	else{
 		match_exp = rule->match_exp;
@@ -397,6 +401,178 @@
 	return re;
 }
 
+void free_pv_match_node(dpl_pv_match_node_p *head)
+{
+	dpl_pv_match_node_p n = *head;
+	while(n)
+	{
+		if(n->comp) pcre_free(n->comp);
+		if(n->expr.s) pkg_free(n->expr.s);
+		*head = n->next;
+		pkg_free(n);
+		n = *head;
+	}
+}
+
+int add_pv_match_node(dpl_pv_match_node_p *head, pcre *comp, str expr)
+{
+	dpl_pv_match_node_p n;
+
+	if(head==NULL||comp==NULL) return -1;
+	n = pkg_malloc(sizeof(dpl_pv_match_node_t));
+	if(n==NULL)
+	{
+		LM_ERR("out of pkg memory\n");
+		return -1;
+	}
+	memset(n, 0, sizeof(dpl_pv_match_node_t));
+	n->comp = comp;
+	n->expr.len = expr.len;
+	n->expr.s = expr.s;
+	n->next = *head;
+	*head = n;
+	LM_DBG("head[%p]->next[%p]\n", *head, (*head)->next);
+	return 0;
+}
+
+int get_pv_avp_param(pv_elem_p match_elem, pv_param_p *avp_param)
+{
+	int num, num_elem;
+	pv_elem_p e;
+
+	if(match_elem==NULL) return -1;
+	for(e = match_elem, num=num_elem=0; e != NULL; e = e->next, num++)
+	{
+		if(e->spec!=NULL)
+		{
+			if(num_elem!=0)
+			{
+				LM_ERR("More than one spec\n");
+				return -1;
+			}
+			num_elem++;
+			if( e->spec->type!=PVT_AVP ||
+				e->spec->pvp.pvi.type!=PV_IDX_ALL)
+			{
+				LM_ERR("spec not AVP or PV_IDX_ALL\n");
+				return -1;
+			}
+			*avp_param = &(e->spec->pvp);
+		}
+	}
+	return 0;
+}
+
+void dlp_print_elem(pv_elem_p elem)
+{
+	pv_elem_p e;
+	int num;
+	for(e=elem, num=0; e!=NULL; e=e->next, num++)
+	{
+		LM_DBG("elem[%d][%p][%.*s][%p]\n", num, e, e->text.len,
+			e->text.s, e->spec);
+	}
+}
+
+int build_pv_match_comp_helper(struct sip_msg *msg,
+	dpl_pv_match_node_p *match_comp, pv_elem_p elem)
+{
+	pcre *comp = NULL;
+	str expr = STR_NULL;
+	int cap_cnt = 0;
+
+	if(pv_printf_s(msg, elem, &expr)<0){
+		LM_ERR("Can't get match expression value\n");
+		return -1;
+	}
+	LM_DBG("final expr:[%.*s]\n", expr.len, expr.s);
+	comp = reg_ex_comp_pv(expr.s, &cap_cnt);
+	if(!comp){
+		LM_ERR("failed to compile match expression %.*s\n",
+				expr.len, expr.s);
+		return -1;
+	}
+	if(add_pv_match_node(match_comp, comp, expr)<0)
+	{
+		LM_ERR("Can't add match node\n");
+		return -1;
+	}
+	LM_DBG("expr:[%.*s] added\n", expr.len, expr.s);
+	return 0;
+}
+
+int build_pv_match_comp(struct sip_msg *msg, dpl_pv_node_t *rule)
+{
+	struct usr_avp *avp;
+	unsigned short name_type;
+	int_str avp_name;
+	int_str avp_value;
+	struct search_state state;
+	pv_param_p avp_param = NULL;
+	pv_elem_p match_elem;
+	str match_exp_orig;
+	str num_index = STR_NULL;
+	char orig_base_buf[256];
+	str match_exp = STR_NULL;
+	int num = 0;
+	int t[3];
+	char *index;
+
+	if(rule->match_comp) free_pv_match_node(&rule->match_comp);
+	LM_DBG("rule[%p]->match_elem[%p]\n", rule, rule->match_elem);
+	dlp_print_elem(rule->match_elem);
+	if(rule->orig->pv_flags&DP_PV_MATCH)
+	{
+		if(build_pv_match_comp_helper(msg, &rule->match_comp,
+			rule->match_elem)<0) return -1;
+	}
+	else if(rule->orig->pv_flags&DP_PV_MATCH_AVP){
+		if(get_pv_avp_param(rule->match_elem, &avp_param)<0) return -1;
+		if(pv_get_avp_name(msg, avp_param, &avp_name, &name_type)!=0)
+		{
+			LM_ERR("invalid avp name\n");
+			return -1;
+		}
+		match_exp_orig.len = rule->orig->match_exp.len;
+		if(rule->orig->pv_flags&DP_PV_MATCH_M) match_exp_orig.len--;
+		match_exp_orig.s = rule->orig->match_exp.s;
+		LM_DBG("match_exp[%.*s]\n", match_exp_orig.len, match_exp_orig.s);
+		index = strstr( match_exp_orig.s,  "[*]");
+		if(!index)
+		{
+			LM_ERR("Cannot find [*] at match_exp\n");
+			return -1;
+		}
+		t[0] = index+1-match_exp_orig.s;
+		t[2] = match_exp_orig.s + match_exp_orig.len - (index+2);
+		strncpy(orig_base_buf, match_exp_orig.s, t[0]);
+		match_exp.s = orig_base_buf;
+		match_exp.len = t[0];
+		avp = search_first_avp(name_type, avp_name, &avp_value, &state);
+		while(avp)
+		{
+			num_index.s = int2str(num, &(num_index.len));
+			strncpy(orig_base_buf+t[0], num_index.s, num_index.len);
+			t[1] = t[0] + num_index.len;
+			match_exp.len = t[1];
+			strncpy(orig_base_buf+match_exp.len, index+2, t[2]);
+			match_exp.len = t[0] + num_index.len + t[2];
+			LM_DBG("final match_exp[%.*s]\n", match_exp.len, match_exp.s);
+			if(pv_parse_format(&match_exp, &match_elem)<0){
+				LM_ERR("parsing match_exp:%.*s\n",
+					match_exp.len, match_exp.s);
+				return -1;
+			}
+			if(build_pv_match_comp_helper(msg, &rule->match_comp,
+				match_elem)<0) return -1;
+			pv_elem_free_all(match_elem);
+			avp = search_next_avp(&state, &avp_value);
+			num++;
+		}
+	}
+	return 0;
+}
+
 int build_pv_comp(struct sip_msg *msg, dpl_pv_node_t *rule)
 {
 	int cap_cnt = 0;
@@ -405,18 +581,9 @@
 	if(!rule)
 		return -1;
 
-	if(rule->orig->pv_flags&DP_PV_MATCH){
-		if(pv_printf_s(msg, rule->match_elem, &(rule->match_exp))<0){
- 			LM_ERR("Can't get match expression value\n");
- 			return -1;
- 		}
- 		if(rule->match_comp) pcre_free(rule->match_comp);
-		rule->match_comp = reg_ex_comp_pv(rule->match_exp.s, &cap_cnt);
-		if(!rule->match_comp){
-			LM_ERR("failed to compile match expression %.*s\n",
-					rule->match_exp.len, rule->match_exp.s);
-			return -1;
-		}
+	if(rule->orig->pv_flags&DP_PV_MATCH||rule->orig->pv_flags&DP_PV_MATCH_AVP)
+	{
+		if(build_pv_match_comp(msg, rule)<0) return -1;
 	}
 
 	if(rule->orig->pv_flags&DP_PV_SUBST){
@@ -436,9 +603,6 @@
 					rule->subst_exp.len, rule->subst_exp.s);
 			return -1;
 		}
-	}
-
-	if(rule->orig->pv_flags&DP_PV_MASK) {
 		repl_comp = rule->orig->repl_comp;
 		if (repl_comp && (cap_cnt < repl_comp->max_pmatch) &&
 				(repl_comp->max_pmatch != 0)) {
@@ -450,6 +614,7 @@
 			return -1;
 		}
 	}
+
 	return 0;
 }
 
@@ -461,7 +626,7 @@
 	dpl_node_p rulep;
 	dpl_pv_node_p rule_pv;
 	dpl_index_p indexp;
-	pcre *match_comp = NULL;
+	dpl_pv_match_node_p n;
 	int user_len, rez;
 	char b;
 
@@ -486,7 +651,10 @@
 
 			case DP_REGEX_OP:
 				LM_DBG("regex operator testing\n");
-				if(rulep->pv_flags&DP_PV_MATCH) {
+				LM_DBG("match:[%.*s] rulep->pv_flags:%d\n",
+					rulep->match_exp.len, rulep->match_exp.s , rulep->pv_flags);
+				if(rulep->pv_flags&DP_PV_MATCH||rulep->pv_flags&DP_PV_MATCH_AVP)
+				{
 					if(!msg) {
 						LM_ERR("Cannot translate using a regex match with pv "
 							"without message\n");
@@ -498,16 +666,26 @@
 							LM_ERR("error rule regex comp. Skip this\n");
 							continue;
 						}
-						match_comp = rule_pv->match_comp;
+						n = rule_pv->match_comp;
+						while(n)
+						{
+							LM_DBG("check: [%.*s]\n", n->expr.len, n->expr.s);
+							rez = pcre_exec(n->comp, NULL, input.s,
+									input.len, 0, 0, NULL, 0);
+							if(rez >= 0) n = NULL;
+							else n = n->next;
+						}
 					}
 					else {
 						LM_ERR("pv rule not found.Skip this\n");
 						continue;
 					}
 				}
-				else match_comp = rulep->match_comp;
-				rez = pcre_exec(match_comp, NULL, input.s, input.len,
+				else
+				{
+					rez = pcre_exec(rulep->match_comp, NULL, input.s, input.len,
 						0, 0, NULL, 0);
+				}
 				break;
 
 			case DP_EQUAL_OP:
