From b53ff04ab062e66d6d7f32777c6e8c80971bbf84 Mon Sep 17 00:00:00 2001
From: Victor Seva <linuxmaniac@torreviejawireless.org>
Date: Thu, 13 Mar 2014 19:28:33 +0100
Subject: [PATCH] MT#6243 add functions to textops to convert and add multipart
 bodies

set_multibody() and append_multibody() functions.

route[TESTING_TEXTOPS]
{
	$var(body)="7e Od 04 55 75 69 20 4d 61 6b 65 43 61 6c 6c";
	set_multibody();
	append_multibody("$var(body)\n","application/vnd.cirpack.isdn-ext", "signal;handling=required");
	append_multibody("$var(body)\n","application/vnd.cirpack.isdn-ext");

	append_hf("X-Test: test\r\n");
	forward(127.2.0.1);
}
---
 modules/textops/textops.c | 386 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 386 insertions(+)

diff --git a/modules/textops/textops.c b/modules/textops/textops.c
index 1085019..ebb63af 100644
--- a/modules/textops/textops.c
+++ b/modules/textops/textops.c
@@ -123,6 +123,9 @@ static int append_time_f(struct sip_msg* msg, char* , char *);
 static int append_time_request_f(struct sip_msg* msg, char* , char *);
 static int set_body_f(struct sip_msg* msg, char*, char *);
 static int set_rpl_body_f(struct sip_msg* msg, char*, char *);
+static int set_multibody_f(struct sip_msg* msg, char*, char *);
+static int append_multibody_f(struct sip_msg* msg, char*, char *, char *);
+static int fixup_append_multibody_f(void** param, int param_no);
 static int is_method_f(struct sip_msg* msg, char* , char *);
 static int has_body_f(struct sip_msg *msg, char *type, char *str2 );
 static int in_list_f(struct sip_msg* _msg, char* _subject, char* _list,
@@ -275,6 +278,18 @@ static cmd_export_t cmds[]={
 
 	{"bind_textops",      (cmd_function)bind_textops,       0, 0, 0,
 		0},
+	{"set_multibody",         (cmd_function)set_multibody_f,        0,
+		0, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|BRANCH_ROUTE|ONREPLY_ROUTE },
+	{"set_multibody",         (cmd_function)set_multibody_f,        2,
+		fixup_spve_spve, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|BRANCH_ROUTE|ONREPLY_ROUTE },
+	{"append_multibody",     (cmd_function)append_multibody_f,    2,
+		fixup_append_multibody_f, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|BRANCH_ROUTE },
+	{"append_multibody",     (cmd_function)append_multibody_f,    3,
+		fixup_append_multibody_f, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|BRANCH_ROUTE },
 
 	{0,0,0,0,0,0}
 };
@@ -1444,7 +1459,378 @@ static int set_rpl_body_f(struct sip_msg* msg, char* p1, char* p2)
 	return 1;
 }
 
+static int generate_boundary(str *txt, str content_type,
+	str content_disposition, str delimiter)
+{
+	unsigned int i = 0;
+	unsigned int ct_len = sizeof("Content-Type: ") -1;
+	unsigned int cd_len = sizeof("Content-Disposition: ") -1;
+	str n = {0,0};
+	if (txt==NULL||txt->len==0||content_type.len==0||delimiter.len==0)
+	{
+		LM_ERR("invalid parameters\n");
+		return -1;
+	}
+
+	n.len=2*(delimiter.len + 2 + CRLF_LEN);
+	n.len=n.len + ct_len + content_type.len + 3*CRLF_LEN;
+	if(content_disposition.s!=NULL)
+	{
+		n.len=n.len + cd_len + content_disposition.len + CRLF_LEN;
+	}
+	n.len=n.len + txt->len;
+
+	n.s=pkg_malloc(sizeof(char)*(n.len));
+	if (n.s==0)
+	{
+		LM_ERR("out of pkg memory\n");
+		return -1;
+	}
+	memcpy(n.s, "--", 2); i=2;
+	memcpy(n.s+i, delimiter.s, delimiter.len); i=i+delimiter.len;
+	memcpy(n.s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+
+	memcpy(n.s+i, "Content-Type: ", ct_len); i=i+ct_len;
+	memcpy(n.s+i, content_type.s, content_type.len); i=i+content_type.len;
+	memcpy(n.s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+	if(content_disposition.s!=NULL)
+	{
+		memcpy(n.s+i, "Content-Disposition: ", cd_len); i=i+cd_len;
+		memcpy(n.s+i, content_disposition.s, content_disposition.len);
+		i=i+content_disposition.len;
+		memcpy(n.s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+	}
+	memcpy(n.s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+
+	memcpy(n.s+i, txt->s, txt->len); i=i+txt->len;
+
+	memcpy(n.s+i, "--", 2); i=i+2;
+	memcpy(n.s+i, delimiter.s, delimiter.len); i=i+delimiter.len;
+	memcpy(n.s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+	memcpy(n.s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+
+	pkg_free(txt->s);
+	txt->len = n.len;
+	txt->s = n.s;
+
+	return 1;
+}
+
+static int set_multibody_f(struct sip_msg* msg, char* p1, char* p2)
+{
+	struct lump *anchor;
+	char* buf = NULL;
+	int len;
+	char* value_s;
+	int value_len;
+	str body = {0,0};
+	str nb = {0,0};
+	str oc = {0,0};
+	str cd = {0,0};
+	str nc = {"multipart/mixed;boundary=\"unique-boundary-1\"",44};
+	str delimiter = {"unique-boundary-1", 17};
+	unsigned int convert = 0;
+	fparam_t header;
+	header.orig = NULL;
+	header.type = FPARAM_STR;
+	header.v.str.s = "Mime-Version: 1.0\r\n";
+	header.v.str.len = 19;
+
+	if(p1==0 || p2==0)
+	{
+		convert = 1;
+	}
+	else
+	{
+		if(fixup_get_svalue(msg, (gparam_p)p1, &nb)!=0)
+		{
+			LM_ERR("unable to get p1\n");
+			return -1;
+		}
+		if(nb.s==NULL || nb.len == 0)
+		{
+			LM_ERR("invalid body parameter\n");
+			return -1;
+		}
+		if(fixup_get_svalue(msg, (gparam_p)p2, &oc)!=0)
+		{
+			LM_ERR("unable to get p2\n");
+			return -1;
+		}
+		if(oc.s==NULL || oc.len == 0)
+		{
+			LM_ERR("invalid content-type parameter\n");
+			return -1;
+		}
+	}
+
+	body.s = get_body(msg);
+	if (body.s==0)
+	{
+		LM_ERR("malformed sip message\n");
+		return -1;
+	}
+
+	del_nonshm_lump( &(msg->body_lumps) );
+	msg->body_lumps = NULL;
 
+	if (msg->content_length)
+	{
+		body.len = get_content_length( msg );
+		if(body.len > 0)
+		{
+			if(body.s+body.len>msg->buf+msg->len)
+			{
+				LM_ERR("invalid content length: %d\n", body.len);
+				return -1;
+			}
+			if(convert)
+			{
+				/* need to copy body */
+				nb.s=pkg_malloc(sizeof(char)*(body.len));
+				if (nb.s==0)
+				{
+					LM_ERR("out of pkg memory\n");
+					return -1;
+				}
+				memcpy(nb.s, body.s, body.len);
+				nb.len = body.len;
+				if(msg->content_type!=NULL && msg->content_type->body.s!=NULL)
+				{
+					oc.s=pkg_malloc(sizeof(char)*(msg->content_type->body.len));
+					if (oc.s==0)
+					{
+						LM_ERR("out of pkg memory\n");
+						goto error;
+					}
+					memcpy(oc.s, msg->content_type->body.s, msg->content_type->body.len);
+					oc.len = msg->content_type->body.len;
+				}
+			}
+			if(del_lump(msg, body.s - msg->buf, body.len, 0) == 0)
+			{
+				LM_ERR("cannot delete existing body");
+				goto error;
+			}
+		}
+	}
+
+	anchor = anchor_lump(msg, msg->unparsed - msg->buf, 0, 0);
+	if (anchor == 0)
+	{
+		LM_ERR("failed to get anchor\n");
+		goto error;
+	}
+
+	/* get initial boundary */
+	if(generate_boundary(&nb, oc, cd, delimiter)<0)
+	{
+		LM_ERR("couldn't create initial boundary\n");
+		goto error;
+	}
+
+	if (msg->content_length==0)
+	{
+		/* need to add Content-Length */
+		len = nb.len;
+		value_s=int2str(len, &value_len);
+
+		len=CONTENT_LENGTH_LEN+value_len+CRLF_LEN;
+		buf=pkg_malloc(sizeof(char)*(len));
+
+		if (buf==0)
+		{
+			LM_ERR("out of pkg memory\n");
+			goto error;
+		}
+
+		memcpy(buf, CONTENT_LENGTH, CONTENT_LENGTH_LEN);
+		memcpy(buf+CONTENT_LENGTH_LEN, value_s, value_len);
+		memcpy(buf+CONTENT_LENGTH_LEN+value_len, CRLF, CRLF_LEN);
+		if (insert_new_lump_after(anchor, buf, len, 0) == 0)
+		{
+			LM_ERR("failed to insert content-length lump\n");
+			goto error;
+		}
+		buf = NULL;
+	}
+
+	/* add content-type */
+	if(msg->content_type==NULL || msg->content_type->body.len!=nc.len
+			|| strncmp(msg->content_type->body.s, nc.s, nc.len)!=0)
+	{
+		if(msg->content_type!=NULL)
+			if(del_lump(msg, msg->content_type->name.s-msg->buf,
+						msg->content_type->len, 0) == 0)
+			{
+				LM_ERR("failed to delete content type\n");
+				goto error;
+			}
+		value_len = nc.len;
+		len=sizeof("Content-Type: ") - 1 + value_len + CRLF_LEN;
+		buf=pkg_malloc(sizeof(char)*(len));
+
+		if (buf==0)
+		{
+			LM_ERR("out of pkg memory\n");
+			goto error;
+		}
+		memcpy(buf, "Content-Type: ", sizeof("Content-Type: ") - 1);
+		memcpy(buf+sizeof("Content-Type: ") - 1, nc.s, value_len);
+		memcpy(buf+sizeof("Content-Type: ") - 1 + value_len, CRLF, CRLF_LEN);
+		if (insert_new_lump_after(anchor, buf, len, 0) == 0)
+		{
+			LM_ERR("failed to insert content-type lump\n");
+			goto error;
+		}
+		buf = NULL;
+	}
+
+	anchor = anchor_lump(msg, body.s - msg->buf, 0, 0);
+	if (anchor == 0)
+	{
+		LM_ERR("failed to get body anchor\n");
+		goto error;
+	}
+
+	buf=pkg_malloc(sizeof(char)*(nb.len));
+	if (buf==0)
+	{
+		LM_ERR("out of pkg memory\n");
+		goto error;
+	}
+	memcpy(buf, nb.s, nb.len);
+	if (insert_new_lump_after(anchor, buf, nb.len, 0) == 0)
+	{
+		LM_ERR("failed to insert body lump\n");
+		goto error;
+	}
+	buf = NULL;
+
+	if(add_hf_helper(msg, 0, 0, &header, 0, 0)<0)
+	{
+		LM_ERR("failed to add Mime-Version header\n");
+		goto error;
+	}
+	return 1;
+
+error:
+	if (buf!=NULL) pkg_free(buf);
+	if (convert && nb.s!=NULL) pkg_free(nb.s);
+	if (convert && oc.s!=NULL) pkg_free(oc.s);
+	return -1;
+}
+
+static int append_multibody_f(struct sip_msg* msg, char* p1, char* p2, char* p3)
+{
+	struct lump *l;
+	int off;
+	str body = {0,0};
+	str nb = {0,0};
+	str nc = {0,0};
+	str cd = {0,0};
+	str txt = {0,0};
+	str delimiter = {"unique-boundary-1", 17};
+
+	if(p1==0 || p2==0)
+	{
+		LM_ERR("invalid parameters\n");
+		return -1;
+	}
+
+	if(fixup_get_svalue(msg, (gparam_p)p1, &txt)!=0)
+	{
+		LM_ERR("unable to get p1\n");
+		return -1;
+	}
+	if(txt.s==NULL || txt.len == 0)
+	{
+		LM_ERR("invalid body parameter\n");
+		return -1;
+	}
+	if(fixup_get_svalue(msg, (gparam_p)p2, &nc)!=0)
+	{
+		LM_ERR("unable to get p2\n");
+		return -1;
+	}
+	if(nc.s==NULL || nc.len == 0)
+	{
+		LM_ERR("invalid content-type parameter\n");
+		return -1;
+	}
+	if(p3!=NULL)
+	{
+		if(fixup_get_svalue(msg, (gparam_p)p3, &cd)!=0)
+		{
+			LM_ERR("unable to get p3\n");
+			return -1;
+		}
+	}
+
+	body.s = get_body(msg);
+	if (body.s==0) {
+		LM_ERR("failed to get the message body\n");
+		return -1;
+	}
+	body.len = msg->len -(int)(body.s-msg->buf);
+	if (body.len==0) {
+		LM_DBG("message body has zero length\n");
+		return -1;
+	}
+
+	off=body.s-msg->buf;
+	if ((l=anchor_lump(msg, off+body.len, 0, 0))==0)
+	{
+		LM_ERR("WTF\n");
+		return -1;
+	}
+	/* get boundary */
+	if(generate_boundary(&txt, nc, cd, delimiter)<0)
+	{
+		LM_ERR("couldn't create initial boundary\n");
+		return -1;
+	}
+	nb.len = txt.len;
+	nb.s = pkg_malloc(sizeof(char)*txt.len);
+	if (nb.s==0)
+	{
+		LM_ERR("out of pkg memory\n");
+		return -1;
+	}
+	memcpy(nb.s, txt.s, txt.len);
+	if (insert_new_lump_after(l, nb.s, nb.len, 0)==0){
+		LM_ERR("could not insert new lump\n");
+		pkg_free(nb.s);
+		return -1;
+	}
+	return 1;
+}
+
+static int fixup_append_multibody_f(void** param, int param_no)
+{
+	int ret;
+	fparam_t* fp;
+
+	if (param_no<=3){
+		if ((ret=fix_param_types(FPARAM_PVE, param))<0){
+			ERR("Cannot convert function parameter %d to spve \n",
+					param_no);
+			return E_UNSPEC;
+		} else {
+			fp=(fparam_t*)*param;
+			if ((ret==0) && (fp->v.pve->spec==0
+						|| fp->v.pve->spec->getf==0)){
+				fparam_free_restore(param);
+				return fix_param_types(FPARAM_STR, param);
+			} else if (ret==1)
+				return fix_param_types(FPARAM_STR, param);
+			return ret;
+		}
+	} else {
+		LM_ERR("wrong number of parameters\n");
+		return E_UNSPEC;
+	}
+}
 
 static int append_to_reply_f(struct sip_msg* msg, char* key, char* str0)
 {
-- 
1.9.0

