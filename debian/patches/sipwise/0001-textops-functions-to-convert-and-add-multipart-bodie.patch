From a810b4b4b0f0597bbad5cd0dd0354dc7afa2dbb0 Mon Sep 17 00:00:00 2001
From: Victor Seva <linuxmaniac@torreviejawireless.org>
Date: Thu, 13 Mar 2014 19:28:33 +0100
Subject: [PATCH 1/4] textops: functions to convert and add multipart bodies

---
 modules/textops/textops.c | 445 ++++++++++++++++++++++++++++++++++++++++++++++
 msg_translator.c          | 243 ++++++++++++++++++++++++-
 parser/msg_parser.h       |   1 +
 3 files changed, 686 insertions(+), 3 deletions(-)

diff --git a/modules/textops/textops.c b/modules/textops/textops.c
index 1085019..63dcd42 100644
--- a/modules/textops/textops.c
+++ b/modules/textops/textops.c
@@ -123,6 +123,10 @@ static int append_time_f(struct sip_msg* msg, char* , char *);
 static int append_time_request_f(struct sip_msg* msg, char* , char *);
 static int set_body_f(struct sip_msg* msg, char*, char *);
 static int set_rpl_body_f(struct sip_msg* msg, char*, char *);
+static int set_multibody_f(struct sip_msg* msg, char*, char *);
+static int append_multibody_2(struct sip_msg* msg, char*, char *);
+static int append_multibody_3(struct sip_msg* msg, char*, char *, char *);
+static int fixup_append_multibody_f(void** param, int param_no);
 static int is_method_f(struct sip_msg* msg, char* , char *);
 static int has_body_f(struct sip_msg *msg, char *type, char *str2 );
 static int in_list_f(struct sip_msg* _msg, char* _subject, char* _list,
@@ -275,6 +279,18 @@ static cmd_export_t cmds[]={
 
 	{"bind_textops",      (cmd_function)bind_textops,       0, 0, 0,
 		0},
+	{"set_body_multipart",         (cmd_function)set_multibody_f,        0,
+		0, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|BRANCH_ROUTE|ONREPLY_ROUTE },
+	{"set_body_multipart",         (cmd_function)set_multibody_f,        2,
+		fixup_spve_spve, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|BRANCH_ROUTE|ONREPLY_ROUTE },
+	{"append_body_part",     (cmd_function)append_multibody_2,    2,
+		fixup_append_multibody_f, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|BRANCH_ROUTE|ONREPLY_ROUTE },
+	{"append_body_part",     (cmd_function)append_multibody_3,    3,
+		fixup_append_multibody_f, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|BRANCH_ROUTE|ONREPLY_ROUTE },
 
 	{0,0,0,0,0,0}
 };
@@ -1444,7 +1460,436 @@ static int set_rpl_body_f(struct sip_msg* msg, char* p1, char* p2)
 	return 1;
 }
 
+static str* generate_boundary(str txt, str content_type,
+	str content_disposition, str delimiter, unsigned int initial)
+{
+	unsigned int i = 0;
+	str cth = {"Content-Type: ", 14};
+	str cdh = {"Content-Disposition: ", 21};
+	str* n;
+	unsigned int flag_sdp = 0;
+
+	if(txt.len==0||content_type.len==0||delimiter.len==0)
+	{
+		LM_ERR("invalid parameters\n");
+		return NULL;
+	}
+	n = pkg_malloc(sizeof(str));
+	if(n==NULL)
+	{
+		LM_ERR("out of pkg memory\n");
+		return NULL;
+	}
+	n->len = delimiter.len + 2 + CRLF_LEN;
+	if(initial) n->len = 2*n->len;
+	if(content_type.len==15 &&
+		strncasecmp("application/sdp", content_type.s, 15)==0 &&
+		strncmp("\r\n\r\n", txt.s+txt.len-4,4)!=0)
+	{
+		n->len = n->len + CRLF_LEN;
+		flag_sdp = 1;
+		LM_DBG("sdp with no CRLF+CRLF\n");
+	}
+	n->len=n->len + cth.len + content_type.len + 2*CRLF_LEN;
+	if(content_disposition.len>0)
+	{
+		n->len = n->len + cdh.len + content_disposition.len + CRLF_LEN;
+	}
+	n->len = n->len + txt.len;
+
+	n->s = pkg_malloc(sizeof(char)*(n->len));
+	if(n->s==0)
+	{
+		LM_ERR("out of pkg memory\n");
+		pkg_free(n);
+		return NULL;
+	}
+	if(initial)
+	{
+		memcpy(n->s, "--", 2); i=2;
+		memcpy(n->s+i, delimiter.s, delimiter.len); i=i+delimiter.len;
+		memcpy(n->s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+	}
+
+	memcpy(n->s+i, cth.s, cth.len); i=i+cth.len;
+	memcpy(n->s+i, content_type.s, content_type.len); i=i+content_type.len;
+	memcpy(n->s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+
+	if(content_disposition.len>0)
+	{
+		memcpy(n->s+i, cdh.s, cdh.len); i=i+cdh.len;
+		memcpy(n->s+i, content_disposition.s, content_disposition.len);
+		i=i+content_disposition.len;
+		memcpy(n->s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+	}
+	memcpy(n->s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+
+	memcpy(n->s+i, txt.s, txt.len); i=i+txt.len;
+	if(flag_sdp) { memcpy(n->s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN; }
+
+	memcpy(n->s+i, "--", 2); i=i+2;
+	memcpy(n->s+i, delimiter.s, delimiter.len); i=i+delimiter.len;
+	memcpy(n->s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+
+	if(i!=n->len)
+	{
+		LM_ERR("out of bounds\n");
+	}
+	return n;
+}
+
+/**
+ * return:
+ *  1: multipart
+ */
+static int check_multipart(struct sip_msg *msg)
+{
+	int mime;
+
+	/* the function search for and parses the Content-Type hdr */
+	mime = parse_content_type_hdr (msg);
+	if(mime<0) {
+		LM_ERR("failed to extract content type hdr\n");
+		return -1;
+	}
+	if(mime!=MIMETYPE(MULTIPART,MIXED)) return 0;
+    return 1;
+}
+
+static int set_multibody_f(struct sip_msg* msg, char* p1, char* p2)
+{
+	struct lump *anchor;
+	char* buf = NULL;
+	int len;
+	char* value_s;
+	int value_len;
+	str body = {0,0};
+	str nb = {0,0};
+	str oc = {0,0};
+	str cd = {0,0};
+	str nc = {"multipart/mixed;boundary=\"unique-boundary-1\"", 44};
+	str delimiter = {"unique-boundary-1", 17};
+	str cth = {"Content-Type: ", 14};
+	str* nbb;
+	unsigned int convert = 0;
+	fparam_t header;
+	header.orig = NULL;
+	header.type = FPARAM_STR;
+	header.v.str.s = "Mime-Version: 1.0\r\n";
+	header.v.str.len = 19;
+
+	if(p1==0 || p2==0)
+	{
+		if(check_multipart(msg)==1) {
+			LM_WARN("body is alredy multipart. Do nothing\n");
+			return -1;
+		}
+		convert = 1;
+	}
+	else
+	{
+		if(fixup_get_svalue(msg, (gparam_p)p1, &nb)!=0)
+		{
+			LM_ERR("unable to get p1\n");
+			return -1;
+		}
+		if(nb.s==NULL || nb.len == 0)
+		{
+			LM_ERR("invalid body parameter\n");
+			return -1;
+		}
+		if(fixup_get_svalue(msg, (gparam_p)p2, &oc)!=0)
+		{
+			LM_ERR("unable to get p2\n");
+			return -1;
+		}
+		if(oc.s==NULL || oc.len==0)
+		{
+			LM_ERR("invalid content-type parameter\n");
+			return -1;
+		}
+		if(check_multipart(msg)==1) {
+			convert = -1;
+		}
+	}
+
+	body.len = 0;
+	body.s = get_body(msg);
+	if(body.s==0)
+	{
+		LM_ERR("malformed sip message\n");
+		return -1;
+	}
+	body.len = msg->len -(int)(body.s-msg->buf);
+
+	del_nonshm_lump( &(msg->body_lumps) );
+	msg->body_lumps = NULL;
+
+	if(msg->content_length)
+	{
+		if(body.len > 0)
+		{
+			if(body.s+body.len>msg->buf+msg->len)
+			{
+				LM_ERR("invalid content length: %d\n", body.len);
+				return -1;
+			}
+			if(convert==1)
+			{
+				/* need to copy body */
+				nb.s=pkg_malloc(sizeof(char)*body.len);
+				if (nb.s==0)
+				{
+					LM_ERR("out of pkg memory\n");
+					return -1;
+				}
+				memcpy(nb.s, body.s, body.len);
+				nb.len = body.len;
+				if(msg->content_type!=NULL && msg->content_type->body.s!=NULL)
+				{
+					oc.len = msg->content_type->body.len;
+					oc.s=pkg_malloc(sizeof(char)*oc.len);
+					if (oc.s==0)
+					{
+						LM_ERR("out of pkg memory\n");
+						goto error;
+					}
+					memcpy(oc.s, msg->content_type->body.s, oc.len);
+				}
+			}
+			if(del_lump(msg, body.s-msg->buf, body.len, 0) == 0)
+			{
+				LM_ERR("cannot delete existing body");
+				goto error;
+			}
+		}
+	}
+
+	anchor = anchor_lump(msg, msg->unparsed-msg->buf, 0, 0);
+	if(anchor==0)
+	{
+		LM_ERR("failed to get anchor\n");
+		goto error;
+	}
+
+	/* get initial boundary */
+	nbb = generate_boundary(nb, oc, cd, delimiter, 1);
+	if(nbb==NULL)
+	{
+		LM_ERR("couldn't create initial boundary\n");
+		goto error;
+	}
 
+	if(msg->content_length==0)
+	{
+		/* need to add Content-Length */
+		len = nbb->len;
+		value_s=int2str(len, &value_len);
+
+		len=CONTENT_LENGTH_LEN+value_len+CRLF_LEN;
+		buf=pkg_malloc(sizeof(char)*len);
+
+		if (buf==0)
+		{
+			LM_ERR("out of pkg memory\n");
+			goto error;
+		}
+
+		memcpy(buf, CONTENT_LENGTH, CONTENT_LENGTH_LEN);
+		memcpy(buf+CONTENT_LENGTH_LEN, value_s, value_len);
+		memcpy(buf+CONTENT_LENGTH_LEN+value_len, CRLF, CRLF_LEN);
+		if (insert_new_lump_after(anchor, buf, len, 0) == 0)
+		{
+			LM_ERR("failed to insert content-length lump\n");
+			goto error;
+		}
+		buf = NULL;
+	}
+
+	if(convert!=-1)
+	{
+		/* add content-type */
+		if(msg->content_type==NULL || msg->content_type->body.len!=nc.len
+				|| strncmp(msg->content_type->body.s, nc.s, nc.len)!=0)
+		{
+			if(msg->content_type!=NULL)
+				if(del_lump(msg, msg->content_type->name.s-msg->buf,
+							msg->content_type->len, 0) == 0)
+				{
+					LM_ERR("failed to delete content type\n");
+					goto error;
+				}
+			value_len = nc.len;
+			len = cth.len + value_len + CRLF_LEN;
+			buf = pkg_malloc(sizeof(char)*len);
+
+			if(buf==0)
+			{
+				LM_ERR("out of pkg memory\n");
+				goto error;
+			}
+			memcpy(buf, cth.s, cth.len);
+			memcpy(buf + cth.len, nc.s, value_len);
+			memcpy(buf + cth.len + value_len, CRLF, CRLF_LEN);
+			if (insert_new_lump_after(anchor, buf, len, 0) == 0)
+			{
+				LM_ERR("failed to insert content-type lump\n");
+				goto error;
+			}
+			buf = NULL;
+		}
+		/* add Mime-Version header */
+		if(add_hf_helper(msg, 0, 0, &header, 0, 0)<0)
+		{
+			LM_ERR("failed to add Mime-Version header\n");
+			goto error;
+		}
+	}
+	anchor = anchor_lump(msg, body.s - msg->buf, 0, 0);
+	if(anchor==0)
+	{
+		LM_ERR("failed to get body anchor\n");
+		goto error;
+	}
+
+	if(insert_new_lump_after(anchor, nbb->s, nbb->len, 0)==0)
+	{
+		LM_ERR("failed to insert body lump\n");
+		goto error;
+	}
+	pkg_free(nbb);
+	LM_DBG("set flag FL_BODY_MULTIPART\n");
+	msg->msg_flags |= FL_BODY_MULTIPART;
+	return 1;
+
+error:
+	if(nbb!=NULL) { pkg_free(nbb->s); pkg_free(nbb); }
+	if(buf!=NULL) pkg_free(buf);
+	if(convert && nb.s!=NULL) pkg_free(nb.s);
+	if(convert && oc.s!=NULL) pkg_free(oc.s);
+	return -1;
+}
+
+int append_multibody_helper(struct sip_msg* msg, char* p1, char* p2, char* p3)
+{
+	struct lump *l;
+	int off;
+	str body = {0,0};
+	str nc = {0,0};
+	str cd = {0,0};
+	str txt = {0,0};
+	str* nbb = NULL;
+	str delimiter = {"unique-boundary-1", 17};
+
+	if(p1==0 || p2==0)
+	{
+		LM_ERR("invalid parameters\n");
+		return -1;
+	}
+
+	if(!(msg->msg_flags&FL_BODY_MULTIPART))
+	{
+		LM_DBG("set flag FL_BODY_MULTIPART\n");
+		msg->msg_flags |= FL_BODY_MULTIPART;
+	}
+
+	if(fixup_get_svalue(msg, (gparam_p)p1, &txt)!=0)
+	{
+		LM_ERR("unable to get p1\n");
+		return -1;
+	}
+	if(txt.s==NULL || txt.len==0)
+	{
+		LM_ERR("invalid body parameter\n");
+		return -1;
+	}
+	if(fixup_get_svalue(msg, (gparam_p)p2, &nc)!=0)
+	{
+		LM_ERR("unable to get p2\n");
+		return -1;
+	}
+	if(nc.s==NULL || nc.len==0)
+	{
+		LM_ERR("invalid content-type parameter\n");
+		return -1;
+	}
+	if(p3!=NULL)
+	{
+		if(fixup_get_svalue(msg, (gparam_p)p3, &cd)!=0)
+		{
+			LM_ERR("unable to get p3\n");
+			return -1;
+		}
+	}
+
+	body.s = get_body(msg);
+	if(body.s==0) {
+		LM_ERR("failed to get the message body\n");
+		return -1;
+	}
+	body.len = msg->len -(int)(body.s-msg->buf);
+	if(body.len==0) {
+		LM_DBG("message body has zero length\n");
+		return -1;
+	}
+
+	off=body.s-msg->buf;
+	if((l=anchor_lump(msg, off+body.len, 0, 0))==0)
+	{
+		LM_ERR("WTF\n");
+		return -1;
+	}
+	/* get boundary */
+	nbb = generate_boundary(txt, nc, cd, delimiter, 0);
+	if(nbb==NULL)
+	{
+		LM_ERR("couldn't create initial boundary\n");
+		return -1;
+	}
+	if(insert_new_lump_after(l, nbb->s, nbb->len, 0)==0){
+		LM_ERR("could not insert new lump\n");
+		pkg_free(nbb->s); pkg_free(nbb);
+		return -1;
+	}
+	pkg_free(nbb);
+	return 1;
+}
+
+static int append_multibody_2(struct sip_msg* msg, char* p1, char* p2)
+{
+	return append_multibody_helper(msg, p1, p2, NULL);
+}
+
+static int append_multibody_3(struct sip_msg* msg, char* p1, char* p2, char *p3)
+{
+	return append_multibody_helper(msg, p1, p2, p3);
+}
+
+static int fixup_append_multibody_f(void** param, int param_no)
+{
+	int ret;
+	fparam_t* fp;
+
+	if(param_no<=3){
+		if((ret=fix_param_types(FPARAM_PVE, param))<0){
+			ERR("Cannot convert function parameter %d to spve \n",
+					param_no);
+			return E_UNSPEC;
+		} else {
+			fp=(fparam_t*)*param;
+			if((ret==0) && (fp->v.pve->spec==0
+						|| fp->v.pve->spec->getf==0)){
+				fparam_free_restore(param);
+				return fix_param_types(FPARAM_STR, param);
+			} else if(ret==1)
+				return fix_param_types(FPARAM_STR, param);
+			return ret;
+		}
+	} else {
+		LM_ERR("wrong number of parameters\n");
+		return E_UNSPEC;
+	}
+}
 
 static int append_to_reply_f(struct sip_msg* msg, char* key, char* str0)
 {
diff --git a/msg_translator.c b/msg_translator.c
index 13b0785..6103f47 100644
--- a/msg_translator.c
+++ b/msg_translator.c
@@ -148,7 +148,7 @@
 #include "cfg/cfg.h"
 #include "parser/parse_to.h"
 #include "forward.h"
-
+#include "str_list.h"
 
 #define append_str_trans(_dest,_src,_len,_msg) \
 	append_str( (_dest), (_src), (_len) );
@@ -1618,7 +1618,243 @@ error:
 	return -1;
 }
 
+static inline int find_line_start(char *text, unsigned int text_len,
+				  char **buf, unsigned int *buf_len)
+{
+	char *ch, *start;
+	unsigned int len;
+
+	start = *buf;
+	len = *buf_len;
+
+	while (text_len <= len) {
+		if (strncmp(text, start, text_len) == 0) {
+			*buf = start;
+			*buf_len = len;
+			return 1;
+		}
+		if ((ch = memchr(start, 13, len - 1))) {
+			if (*(ch + 1) != 10) {
+				LM_ERR("No LF after CR\n");
+				return 0;
+			}
+			len = len - (ch - start + 2);
+			start = ch + 2;
+		} else {
+			LM_ERR("No CRLF found\n");
+			return 0;
+		}
+	}
+	return 0;
+}
+
+static inline int get_line(str s)
+{
+	char *ch;
+
+	if ((ch = memchr(s.s, 13, s.len))) {
+		if (*(ch + 1) != 10) {
+			LM_ERR("No LF after CR\n");
+			return 0;
+		}
+		return ch - s.s + 2;
+	} else {
+		LM_ERR("No CRLF found\n");
+		return s.len;
+	}
+	return 0;
+}
+
+int replace_body(struct sip_msg *msg, str txt)
+{
+	struct lump *anchor;
+	char *buf;
+	str body = {0,0};
+
+	body.s = get_body(msg);
+	if(body.s==0)
+	{
+		LM_ERR("malformed sip message\n");
+		return 0;
+	}
+	body.len = msg->len -(int)(body.s-msg->buf);
+	LM_DBG("old size body[%d] actual[%d]\n", body.len, txt.len);
+	if(body.s+body.len>msg->buf+msg->len)
+	{
+		LM_ERR("invalid content length: %d\n", body.len);
+		return 0;
+	}
+	del_nonshm_lump( &(msg->body_lumps) );
+	msg->body_lumps = NULL;
+
+	if(del_lump(msg, body.s-msg->buf, body.len, 0) == 0)
+	{
+		LM_ERR("cannot delete existing body");
+		return 0;
+	}
+
+	anchor = anchor_lump(msg, body.s - msg->buf, 0, 0);
+	if(anchor==0)
+	{
+		LM_ERR("failed to get anchor\n");
+		return 0;
+	}
+
+	buf=pkg_malloc(sizeof(char)*txt.len);
+	if(buf==0)
+	{
+		PKG_MEM_ERROR;
+		return 0;
+	}
+	memcpy(buf, txt.s, txt.len);
+	if(insert_new_lump_after(anchor, buf, txt.len, 0)==0)
+	{
+		LM_ERR("failed to insert body lump\n");
+		pkg_free(buf);
+		return 0;
+	}
+	return 1;
+}
+
+int check_boundaries(struct sip_msg *msg, struct dest_info *send_info)
+{
+	str b = {"--unique-boundary-1\r\n", 21};
+	str fb = {"--unique-boundary-1--\r\n", 23};
+	str body = {0,0};
+	str buf = {0,0};
+	str tmp = {0,0};
+	struct str_list* lb = NULL;
+	struct str_list* lb_t = NULL;
+	int lb_found = 0;
+	int t, ret, lb_size;
+	char *pb;
+
+	if(msg->msg_flags&FL_BODY_MULTIPART)
+	{
+		buf.s = build_body(msg, (unsigned int *)&buf.len, &ret, send_info);
+		if(ret) {
+			LM_ERR("Can't get body\n");
+			return -1;
+		}
+		tmp.s = buf.s;
+		t = tmp.len = buf.len; ret = b.len-2;
+		while(t>0)
+		{
+			if(find_line_start(b.s, ret, &tmp.s,
+				(unsigned int *)&tmp.len))
+			{
+				LM_DBG("found t[%d] tmp.len[%d]:[%.*s]\n",
+					t, tmp.len, tmp.len, tmp.s);
+				if(!lb)
+				{
+					lb = pkg_malloc(sizeof(struct str_list));
+					if (!lb) {
+						PKG_MEM_ERROR;
+						goto error;
+					}
+					lb->s.s = tmp.s;
+					lb->s.len = tmp.len;
+					lb->next = 0;
+					lb_t = lb;
+				}
+				else
+				{
+					lb_t = append_str_list(tmp.s, tmp.len, &lb_t, &lb_size);
+				}
+				lb_found = lb_found + 1;
+				tmp.s = tmp.s + ret;
+				t = tmp.len = t - ret;
+			}
+			else { t=0; }
+		}
+		if(lb_found<2)
+		{
+			LM_ERR("found[%d] wrong number of boundaries\n", lb_found);
+			goto error;
+		}
+		// adding 2 chars in advance
+		body.len = buf.len + 2;
+		body.s = pkg_malloc(sizeof(char)*body.len);
+		if (!body.s) {
+			PKG_MEM_ERROR;
+			goto error;
+		}
+		pb = body.s; body.len = 0;
+		while(lb)
+		{
+			lb_t = lb->next;
+			if(lb_t)
+			{
+				tmp.s = lb->s.s; tmp.len = lb->s.len;
+				tmp.len = get_line(lb->s);
+				if(tmp.len!=b.len || strncmp(b.s, tmp.s, b.len)!=0)
+				{
+					LM_DBG("malformed bondary[%d][%.*s] in the middle\n",
+						tmp.len, tmp.len, tmp.s);
+					memcpy(pb, b.s, b.len); body.len = body.len + b.len;
+					pb = pb + b.len;
+					t = lb_t->s.s - (lb->s.s + tmp.len);
+					memcpy(pb, lb->s.s+tmp.len, t); pb = pb + t;
+					LM_DBG("new chunk[%d][%.*s]\n", t, t, pb-t);
+				}
+				else {
+					t = lb_t->s.s - lb->s.s;
+					memcpy(pb, lb->s.s, t);
+					LM_DBG("copy[%d][%.*s]\n", t, t, pb);
+					pb = pb + t;
+				}
+				body.len = body.len + t;
+				LM_DBG("body[%d][%.*s]\n", body.len, body.len, body.s);
+			}
+			else
+			{	// last boundary
+				tmp.s = lb->s.s; tmp.len = lb->s.len;
+				tmp.len = get_line(lb->s);
+				if(tmp.len!=fb.len || strncmp(fb.s,	tmp.s, fb.len)!=0)
+				{
+					LM_DBG("last bondary[%d][%.*s] without -- at the end\n",
+						tmp.len, tmp.len, tmp.s);
+					memcpy(pb, fb.s, fb.len);
+					LM_DBG("new chunk[%d][%.*s]\n", fb.len, fb.len, pb);
+					pb = pb + fb.len;
+					body.len = body.len + fb.len;
+				}
+				else {
+					memcpy(pb, lb->s.s, lb->s.len); pb = pb + lb->s.len;
+					body.len = body.len + lb->s.len;
+					LM_DBG("copy[%d][%.*s]\n", lb->s.len, lb->s.len, pb - lb->s.len);
+				}
+				LM_DBG("body[%d][%.*s] expected[%ld]\n",
+					body.len, body.len, body.s, pb-body.s);
+			}
+			lb = lb_t;
+		}
+		//LM_DBG("body[%d]:[%.*s]\n", body.len, body.len, body.s);
+		if(!replace_body(msg, body))
+		{
+			LM_ERR("Can't replace body\n");
+			goto error;
+		}
+		msg->msg_flags &= ~FL_BODY_MULTIPART;
+		ret = 1;
+		goto clean;
+	}
+	ret = 0;
+	goto clean;
 
+error:
+	ret = -1;
+clean:
+	if(body.s) pkg_free(body.s);
+	if(buf.s) pkg_free(buf.s);
+	while(lb)
+	{
+		lb_t = lb->next;
+		pkg_free(lb);
+		lb = lb_t;
+	}
+	return ret;
+}
 
 /** builds a request in memory from another sip request.
   *
@@ -1698,6 +1934,9 @@ char * build_req_buf_from_sip_req( struct sip_msg* msg,
 	path_buf.len=0;
 
 	flags=msg->msg_flags|global_req_flags;
+	if(check_boundaries(msg, send_info)<0){
+		LM_WARN("check_boundaries error\n");
+	}
 	/* Calculate message body difference and adjust Content-Length */
 	body_delta = lumps_len(msg, msg->body_lumps, send_info);
 	if (adjust_clen(msg, body_delta, send_info->proto) < 0) {
@@ -1954,8 +2193,6 @@ error00:
 	return 0;
 }
 
-
-
 char * generate_res_buf_from_sip_res( struct sip_msg* msg,
 				unsigned int *returned_len, unsigned int mode)
 {
diff --git a/parser/msg_parser.h b/parser/msg_parser.h
index 724ebef..f25bec9 100644
--- a/parser/msg_parser.h
+++ b/parser/msg_parser.h
@@ -121,6 +121,7 @@ typedef enum request_method {
 #define FL_USE_UAC_TO        (1<<14)  /* take TO hdr from UAC instead of UAS */
 #define FL_TM_RPL_MATCHED    (1<<15)  /* tm matched reply already */
 #define FL_RPL_SUSPENDED     (1<<16)  /* for async reply processing */
+#define FL_BODY_MULTIPART    (1<<17)  /* body modified is multipart */
 
 /* WARNING: Value (1 << 28) is temporarily reserved for use in kamailio call_control
  * module (flag  FL_USE_CALL_CONTROL )! */
-- 
1.9.0

