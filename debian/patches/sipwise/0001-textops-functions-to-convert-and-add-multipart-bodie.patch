From 50fdb6a863f36c9f5977ca6f52bfaf974cb674b1 Mon Sep 17 00:00:00 2001
From: Victor Seva <linuxmaniac@torreviejawireless.org>
Date: Thu, 20 Mar 2014 15:24:42 +0100
Subject: [PATCH] simple

(cherry picked from commit 5fbee6b6c0a2b666a7db63a04f357d2f8e57b6b6)
---
 modules/textops/textops.c | 442 ++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 442 insertions(+)

diff --git a/modules/textops/textops.c b/modules/textops/textops.c
index 1085019..acb97b5 100644
--- a/modules/textops/textops.c
+++ b/modules/textops/textops.c
@@ -123,6 +123,10 @@ static int append_time_f(struct sip_msg* msg, char* , char *);
 static int append_time_request_f(struct sip_msg* msg, char* , char *);
 static int set_body_f(struct sip_msg* msg, char*, char *);
 static int set_rpl_body_f(struct sip_msg* msg, char*, char *);
+static int set_multibody_f(struct sip_msg* msg, char*, char *);
+static int append_multibody_2(struct sip_msg* msg, char*, char *);
+static int append_multibody_3(struct sip_msg* msg, char*, char *, char *);
+static int fixup_append_multibody_f(void** param, int param_no);
 static int is_method_f(struct sip_msg* msg, char* , char *);
 static int has_body_f(struct sip_msg *msg, char *type, char *str2 );
 static int in_list_f(struct sip_msg* _msg, char* _subject, char* _list,
@@ -275,6 +279,18 @@ static cmd_export_t cmds[]={
 
 	{"bind_textops",      (cmd_function)bind_textops,       0, 0, 0,
 		0},
+	{"set_body_multipart",         (cmd_function)set_multibody_f,        0,
+		0, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|BRANCH_ROUTE|ONREPLY_ROUTE },
+	{"set_body_multipart",         (cmd_function)set_multibody_f,        2,
+		fixup_spve_spve, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|BRANCH_ROUTE|ONREPLY_ROUTE },
+	{"append_body_part",     (cmd_function)append_multibody_2,    2,
+		fixup_append_multibody_f, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|BRANCH_ROUTE|ONREPLY_ROUTE },
+	{"append_body_part",     (cmd_function)append_multibody_3,    3,
+		fixup_append_multibody_f, 0,
+		REQUEST_ROUTE|FAILURE_ROUTE|BRANCH_ROUTE|ONREPLY_ROUTE },
 
 	{0,0,0,0,0,0}
 };
@@ -1444,7 +1460,433 @@ static int set_rpl_body_f(struct sip_msg* msg, char* p1, char* p2)
 	return 1;
 }
 
+// flag == 1 initial
+static int generate_boundary(str *txt, str content_type,
+	str content_disposition, str delimiter, unsigned int flag)
+{
+	unsigned int i = 0;
+	str cth = {"Content-Type: ", 14};
+	str cdh = {"Content-Disposition: ", 21};
+	str n = {0,0};
+	unsigned int flag_sdp = 0;
+
+	if (txt==NULL||txt->len==0||content_type.len==0||delimiter.len==0)
+	{
+		LM_ERR("invalid parameters\n");
+		return -1;
+	}
+
+	n.len=delimiter.len + 2 + CRLF_LEN;
+	if(flag) n.len = 2*n.len;
+	if(content_type.len==15 &&
+		strncasecmp("application/sdp", content_type.s, 15)==0 &&
+		strncmp("\r\n\r\n", txt->s+txt->len-4,4)!=0)
+	{
+		n.len=n.len + CRLF_LEN;
+		flag_sdp = 1;
+		LM_DBG("sdp with no CRLF+CRLF\n");
+	}
+	n.len=n.len + cth.len + content_type.len + 2*CRLF_LEN;
+	if(content_disposition.s!=NULL)
+	{
+		n.len=n.len + cdh.len + content_disposition.len + CRLF_LEN;
+	}
+	n.len=n.len + txt->len;
+
+	n.s=pkg_malloc(sizeof(char)*n.len);
+	if (n.s==0)
+	{
+		LM_ERR("out of pkg memory\n");
+		return -1;
+	}
+	if(flag)
+	{
+		memcpy(n.s, "--", 2); i=2;
+		memcpy(n.s+i, delimiter.s, delimiter.len); i=i+delimiter.len;
+		memcpy(n.s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+	}
+
+	memcpy(n.s+i, cth.s, cth.len); i=i+cth.len;
+	memcpy(n.s+i, content_type.s, content_type.len); i=i+content_type.len;
+	memcpy(n.s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+	if(content_disposition.s!=NULL)
+	{
+		memcpy(n.s+i, cdh.s, cdh.len); i=i+cdh.len;
+		memcpy(n.s+i, content_disposition.s, content_disposition.len);
+		i=i+content_disposition.len;
+		memcpy(n.s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+	}
+	memcpy(n.s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+
+	memcpy(n.s+i, txt->s, txt->len); i=i+txt->len;
+	if(flag_sdp) { memcpy(n.s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN; }
+
+	memcpy(n.s+i, "--", 2); i=i+2;
+	memcpy(n.s+i, delimiter.s, delimiter.len); i=i+delimiter.len;
+	memcpy(n.s+i, CRLF, CRLF_LEN); i=i+CRLF_LEN;
+
+	pkg_free(txt->s);
+	txt->len = n.len;
+	txt->s = n.s;
+	return 1;
+}
+
+/**
+ * return:
+ *  1: multipart
+ */
+static int check_multipart(struct sip_msg *msg)
+{
+	int mime;
+
+	/* the function search for and parses the Content-Type hdr */
+	mime = parse_content_type_hdr (msg);
+	if (mime<0) {
+		LM_ERR("failed to extract content type hdr\n");
+		return -1;
+	}
+	if(mime!=MIMETYPE(MULTIPART,MIXED)) return 0;
+    return 1;
+}
+
+static int set_multibody_f(struct sip_msg* msg, char* p1, char* p2)
+{
+	struct lump *anchor;
+	char* buf = NULL;
+	int len;
+	char* value_s;
+	int value_len;
+	str body = {0,0};
+	str nb = {0,0};
+	str oc = {0,0};
+	str cd = {0,0};
+	str nc = {"multipart/mixed;boundary=\"unique-boundary-1\"",44};
+	str delimiter = {"unique-boundary-1", 17};
+	str cth = {"Content-Type: ", 14};
+	unsigned int convert = 0;
+	fparam_t header;
+	header.orig = NULL;
+	header.type = FPARAM_STR;
+	header.v.str.s = "Mime-Version: 1.0\r\n";
+	header.v.str.len = 19;
+
+	if(p1==0 || p2==0)
+	{
+		if(check_multipart(msg)==1) {
+			LM_WARN("body is alredy multipart. Do nothing\n");
+			return -1;
+		}
+		convert = 1;
+	}
+	else
+	{
+		if(fixup_get_svalue(msg, (gparam_p)p1, &nb)!=0)
+		{
+			LM_ERR("unable to get p1\n");
+			return -1;
+		}
+		if(nb.s==NULL || nb.len == 0)
+		{
+			LM_ERR("invalid body parameter\n");
+			return -1;
+		}
+		if(fixup_get_svalue(msg, (gparam_p)p2, &oc)!=0)
+		{
+			LM_ERR("unable to get p2\n");
+			return -1;
+		}
+		if(oc.s==NULL || oc.len == 0)
+		{
+			LM_ERR("invalid content-type parameter\n");
+			return -1;
+		}
+		if(check_multipart(msg)==1) {
+			convert = -1;
+		}
+	}
+
+	body.len = 0;
+	body.s = get_body(msg);
+	if (body.s==0)
+	{
+		LM_ERR("malformed sip message\n");
+		return -1;
+	}
+
+	del_nonshm_lump( &(msg->body_lumps) );
+	msg->body_lumps = NULL;
+
+	if (msg->content_length)
+	{
+		body.len = get_content_length( msg );
+		if(body.len > 0)
+		{
+			if(body.s+body.len>msg->buf+msg->len)
+			{
+				LM_ERR("invalid content length: %d\n", body.len);
+				return -1;
+			}
+			if(convert==1)
+			{
+				/* need to copy body */
+				nb.s=pkg_malloc(sizeof(char)*body.len);
+				if (nb.s==0)
+				{
+					LM_ERR("out of pkg memory\n");
+					return -1;
+				}
+				memcpy(nb.s, body.s, body.len);
+				nb.len = body.len;
+				if(msg->content_type!=NULL && msg->content_type->body.s!=NULL)
+				{
+					oc.len = msg->content_type->body.len;
+					oc.s=pkg_malloc(sizeof(char)*oc.len);
+					if (oc.s==0)
+					{
+						LM_ERR("out of pkg memory\n");
+						goto error;
+					}
+					memcpy(oc.s, msg->content_type->body.s, oc.len);
+				}
+			}
+			if(del_lump(msg, body.s - msg->buf, body.len, 0) == 0)
+			{
+				LM_ERR("cannot delete existing body");
+				goto error;
+			}
+		}
+	}
+
+	anchor = anchor_lump(msg, msg->unparsed - msg->buf, 0, 0);
+	if (anchor == 0)
+	{
+		LM_ERR("failed to get anchor\n");
+		goto error;
+	}
+
+	/* get initial boundary */
+	if(generate_boundary(&nb, oc, cd, delimiter, 1)<0)
+	{
+		LM_ERR("couldn't create initial boundary\n");
+		goto error;
+	}
+
+	if (msg->content_length==0)
+	{
+		/* need to add Content-Length */
+		len = nb.len;
+		value_s=int2str(len, &value_len);
+
+		len=CONTENT_LENGTH_LEN+value_len+CRLF_LEN;
+		buf=pkg_malloc(sizeof(char)*len);
+
+		if (buf==0)
+		{
+			LM_ERR("out of pkg memory\n");
+			goto error;
+		}
 
+		memcpy(buf, CONTENT_LENGTH, CONTENT_LENGTH_LEN);
+		memcpy(buf+CONTENT_LENGTH_LEN, value_s, value_len);
+		memcpy(buf+CONTENT_LENGTH_LEN+value_len, CRLF, CRLF_LEN);
+		if (insert_new_lump_after(anchor, buf, len, 0) == 0)
+		{
+			LM_ERR("failed to insert content-length lump\n");
+			goto error;
+		}
+		buf = NULL;
+	}
+
+	if (convert!=-1)
+	{
+		/* add content-type */
+		if(msg->content_type==NULL || msg->content_type->body.len!=nc.len
+				|| strncmp(msg->content_type->body.s, nc.s, nc.len)!=0)
+		{
+			if(msg->content_type!=NULL)
+				if(del_lump(msg, msg->content_type->name.s-msg->buf,
+							msg->content_type->len, 0) == 0)
+				{
+					LM_ERR("failed to delete content type\n");
+					goto error;
+				}
+			len=cth.len + nc.len + CRLF_LEN;
+			buf=pkg_malloc(sizeof(char)*len);
+
+			if (buf==0)
+			{
+				LM_ERR("out of pkg memory\n");
+				goto error;
+			}
+			memcpy(buf, cth.s, cth.len);
+			memcpy(buf + cth.len, nc.s, nc.len);
+			memcpy(buf + cth.len + nc.len, CRLF, CRLF_LEN);
+			if (insert_new_lump_after(anchor, buf, len, 0) == 0)
+			{
+				LM_ERR("failed to insert content-type lump\n");
+				goto error;
+			}
+			buf = NULL;
+		}
+		/* add Mime-Version header */
+		if(add_hf_helper(msg, 0, 0, &header, 0, 0)<0)
+		{
+			LM_ERR("failed to add Mime-Version header\n");
+			goto error;
+		}
+	}
+	anchor = anchor_lump(msg, body.s - msg->buf, 0, 0);
+	if (anchor == 0)
+	{
+		LM_ERR("failed to get body anchor\n");
+		goto error;
+	}
+
+	buf=pkg_malloc(sizeof(char)*(nb.len));
+	if (buf==0)
+	{
+		LM_ERR("out of pkg memory\n");
+		goto error;
+	}
+	memcpy(buf, nb.s, nb.len);
+	if (insert_new_lump_after(anchor, buf, nb.len, 0) == 0)
+	{
+		LM_ERR("failed to insert body lump\n");
+		goto error;
+	}
+	buf = NULL;
+
+	return 1;
+
+error:
+	if (buf!=NULL) pkg_free(buf);
+	if (convert && nb.s!=NULL) pkg_free(nb.s);
+	if (convert && oc.s!=NULL) pkg_free(oc.s);
+	return -1;
+}
+
+int append_multibody_helper(struct sip_msg* msg, char* p1, char* p2, char* p3)
+{
+	struct lump *l;
+	int off;
+	str body = {0,0};
+	str nb = {0,0};
+	str nc = {0,0};
+	str cd = {0,0};
+	str txt = {0,0};
+	str delimiter = {"unique-boundary-1", 17};
+
+	if(p1==0 || p2==0)
+	{
+		LM_ERR("invalid parameters\n");
+		return -1;
+	}
+
+	if(fixup_get_svalue(msg, (gparam_p)p1, &txt)!=0)
+	{
+		LM_ERR("unable to get p1\n");
+		return -1;
+	}
+	if(txt.s==NULL || txt.len == 0)
+	{
+		LM_ERR("invalid body parameter\n");
+		return -1;
+	}
+	if(fixup_get_svalue(msg, (gparam_p)p2, &nc)!=0)
+	{
+		LM_ERR("unable to get p2\n");
+		return -1;
+	}
+	if(nc.s==NULL || nc.len == 0)
+	{
+		LM_ERR("invalid content-type parameter\n");
+		return -1;
+	}
+	if(p3!=NULL)
+	{
+		if(fixup_get_svalue(msg, (gparam_p)p3, &cd)!=0)
+		{
+			LM_ERR("unable to get p3\n");
+			return -1;
+		}
+	}
+
+	body.s = get_body(msg);
+	if (body.s==0) {
+		LM_ERR("failed to get the message body\n");
+		return -1;
+	}
+	body.len = msg->len -(int)(body.s-msg->buf);
+	if (body.len==0) {
+		LM_DBG("message body has zero length\n");
+		return -1;
+	}
+
+	off=body.s-msg->buf;
+	if ((l=anchor_lump(msg, off+body.len, 0, 0))==0)
+	{
+		LM_ERR("WTF\n");
+		return -1;
+	}
+	/* get boundary */
+	if(generate_boundary(&txt, nc, cd, delimiter, 0)<0)
+	{
+		LM_ERR("couldn't create initial boundary\n");
+		return -1;
+	}
+	nb.len = txt.len + 4;
+	nb.s = pkg_malloc(sizeof(char)*nb.len);
+	if (nb.s==0)
+	{
+		LM_ERR("out of pkg memory\n");
+		return -1;
+	}
+	memcpy(nb.s, txt.s, txt.len-2);
+	memcpy(nb.s+txt.len-2, "--", 2);
+	memcpy(nb.s+txt.len, "\r\n\r\n", 4);
+	if (insert_new_lump_after(l, nb.s, nb.len, 0)==0){
+		LM_ERR("could not insert new lump\n");
+		pkg_free(nb.s);
+		return -1;
+	}
+	return 1;
+}
+
+static int append_multibody_2(struct sip_msg* msg, char* p1, char* p2)
+{
+	return append_multibody_helper(msg, p1, p2, NULL);
+}
+
+static int append_multibody_3(struct sip_msg* msg, char* p1, char* p2, char* p3)
+{
+	return append_multibody_helper(msg, p1, p2, p3);
+}
+
+static int fixup_append_multibody_f(void** param, int param_no)
+{
+	int ret;
+	fparam_t* fp;
+
+	if (param_no<=3){
+		if ((ret=fix_param_types(FPARAM_PVE, param))<0){
+			ERR("Cannot convert function parameter %d to spve \n",
+					param_no);
+			return E_UNSPEC;
+		} else {
+			fp=(fparam_t*)*param;
+			if ((ret==0) && (fp->v.pve->spec==0
+						|| fp->v.pve->spec->getf==0)){
+				fparam_free_restore(param);
+				return fix_param_types(FPARAM_STR, param);
+			} else if (ret==1)
+				return fix_param_types(FPARAM_STR, param);
+			return ret;
+		}
+	} else {
+		LM_ERR("wrong number of parameters\n");
+		return E_UNSPEC;
+	}
+}
 
 static int append_to_reply_f(struct sip_msg* msg, char* key, char* str0)
 {
-- 
1.9.0

