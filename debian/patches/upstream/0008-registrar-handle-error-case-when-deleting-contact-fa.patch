From efb2670ef03b69cb0ae26e7c9ac427c995ffbacf Mon Sep 17 00:00:00 2001
From: Daniel-Constantin Mierla <miconda@gmail.com>
Date: Mon, 9 Dec 2013 10:05:11 +0100
Subject: [PATCH] registrar: handle error case when deleting contact fails for
 unregister()

- reformatted file

(cherry picked from commit 67d218e29457ffd75148c8c520b26ec6f3f41719)
---
 modules/registrar/save.c | 103 ++++++++++++++++++++++++-----------------------
 1 file changed, 52 insertions(+), 51 deletions(-)

diff --git a/modules/registrar/save.c b/modules/registrar/save.c
index fc5d564..caa81df 100644
--- a/modules/registrar/save.c
+++ b/modules/registrar/save.c
@@ -95,7 +95,7 @@ static inline int star(sip_msg_t *_m, udomain_t* _d, str* _a, str *_h)
 {
 	urecord_t* r;
 	ucontact_t* c;
-	
+
 	ul.lock_udomain(_d, _a);
 
 	if (!ul.get_urecord(_d, _a, &r)) {
@@ -114,11 +114,11 @@ static inline int star(sip_msg_t *_m, udomain_t* _d, str* _a, str *_h)
 
 	if (ul.delete_urecord(_d, _a, r) < 0) {
 		LM_ERR("failed to remove record from usrloc\n");
-		
-		     /* Delete failed, try to get corresponding
-		      * record structure and send back all existing
-		      * contacts
-		      */
+
+		/* Delete failed, try to get corresponding
+		 * record structure and send back all existing
+		 * contacts
+		 */
 		rerrno = R_UL_DEL_R;
 		if (!ul.get_urecord(_d, _a, &r)) {
 			build_contact(_m, r->contacts, _h);
@@ -133,7 +133,7 @@ static inline int star(sip_msg_t *_m, udomain_t* _d, str* _a, str *_h)
 
 
 /*! \brief
- */
+*/
 static struct socket_info *get_sock_val(struct sip_msg *msg)
 {
 	struct socket_info *sock;
@@ -179,10 +179,10 @@ static struct socket_info *get_sock_val(struct sip_msg *msg)
 		socks = vavp->val.v.s;
 	}
 	if (parse_phostport( socks.s, &hosts.s, &hosts.len,
-	&port, &proto)!=0) {
+				&port, &proto)!=0) {
 		socks.s[socks.len] = c;
 		LM_ERR("bad socket <%.*s> in \n",
-			socks.len, socks.s);
+				socks.len, socks.s);
 		return 0;
 	}
 	if(sock_hdr_name.len>0 && c!=0) {
@@ -211,7 +211,7 @@ static inline int no_contacts(sip_msg_t *_m, udomain_t* _d, str* _a, str* _h)
 {
 	urecord_t* r;
 	int res;
-	
+
 	ul.lock_udomain(_d, _a);
 	res = ul.get_urecord(_d, _a, &r);
 	if (res < 0) {
@@ -220,7 +220,7 @@ static inline int no_contacts(sip_msg_t *_m, udomain_t* _d, str* _a, str* _h)
 		ul.unlock_udomain(_d, _a);
 		return -1;
 	}
-	
+
 	if (res == 0) {  /* Contacts found */
 		build_contact(_m, r->contacts, _h);
 		ul.release_urecord(r);
@@ -280,7 +280,7 @@ static inline ucontact_info_t* pack_ci( struct sip_msg* _m, contact_t* _c, unsig
 
 		/* set tcp connection id */
 		if (_m->rcv.proto==PROTO_TCP || _m->rcv.proto==PROTO_TLS
-		        || _m->rcv.proto==PROTO_WS  || _m->rcv.proto==PROTO_WSS) {
+				|| _m->rcv.proto==PROTO_WS  || _m->rcv.proto==PROTO_WSS) {
 			ci.tcpconn_id = _m->rcv.proto_reserved1;
 		} else {
 			ci.tcpconn_id = -1;
@@ -288,7 +288,7 @@ static inline ucontact_info_t* pack_ci( struct sip_msg* _m, contact_t* _c, unsig
 
 		/* additional info from message */
 		if (parse_headers(_m, HDR_USERAGENT_F, 0) != -1 && _m->user_agent &&
-		_m->user_agent->body.len>0 && _m->user_agent->body.len<MAX_UA_SIZE) {
+				_m->user_agent->body.len>0 && _m->user_agent->body.len<MAX_UA_SIZE) {
 			ci.user_agent = &_m->user_agent->body;
 		} else {
 			ci.user_agent = &no_ua;
@@ -379,8 +379,8 @@ static inline ucontact_info_t* pack_ci( struct sip_msg* _m, contact_t* _c, unsig
 				if (received_found==0) {
 					memset(&val, 0, sizeof(int_str));
 					if (rcv_avp_name.n!=0
-								&& search_first_avp(rcv_avp_type, rcv_avp_name, &val, 0)
-								&& val.s.len > 0) {
+							&& search_first_avp(rcv_avp_type, rcv_avp_name, &val, 0)
+							&& val.s.len > 0) {
 						if (val.s.len>RECEIVED_MAX_SIZE) {
 							rerrno = R_CONTACT_LEN;
 							LM_ERR("received too long\n");
@@ -574,13 +574,13 @@ error:
 
 
 static int test_max_contacts(struct sip_msg* _m, urecord_t* _r, contact_t* _c,
-										ucontact_info_t *ci, int mc)
+		ucontact_info_t *ci, int mc)
 {
 	int num;
 	int e;
 	ucontact_t* ptr, *cont;
 	int ret;
-	
+
 	num = 0;
 	ptr = _r->contacts;
 	while(ptr) {
@@ -590,7 +590,7 @@ static int test_max_contacts(struct sip_msg* _m, urecord_t* _r, contact_t* _c,
 		ptr = ptr->next;
 	}
 	LM_DBG("%d valid contacts\n", num);
-	
+
 	for( ; _c ; _c = get_next_contact(_c) ) {
 		/* calculate expires */
 		calc_contact_expires(_m, _c->expires, &e);
@@ -610,7 +610,7 @@ static int test_max_contacts(struct sip_msg* _m, urecord_t* _r, contact_t* _c,
 			if (e == 0) num--;
 		}
 	}
-	
+
 	LM_DBG("%d contacts after commit\n", num);
 	if (num > mc) {
 		LM_INFO("too many contacts for AOR <%.*s>\n", _r->aor.len, _r->aor.s);
@@ -668,7 +668,7 @@ static inline int update_contacts(struct sip_msg* _m, urecord_t* _r, int _mode,
 
 #ifdef USE_TCP
 	if ( (_m->flags&tcp_persistent_flag) &&
-	(_m->rcv.proto==PROTO_TCP||_m->rcv.proto==PROTO_TLS||_m->rcv.proto==PROTO_WS||_m->rcv.proto==PROTO_WSS)) {
+			(_m->rcv.proto==PROTO_TCP||_m->rcv.proto==PROTO_TLS||_m->rcv.proto==PROTO_WS||_m->rcv.proto==PROTO_WSS)) {
 		e_max = -1;
 		tcp_check = 1;
 	} else {
@@ -756,15 +756,15 @@ static inline int update_contacts(struct sip_msg* _m, urecord_t* _r, int _mode,
 				/* If call-id has changed then delete all records with this sip.instance
 				   then insert new record */
 				if (ci->instance.s != NULL &&
-					(ci->callid->len != c->callid.len ||
-						strncmp(ci->callid->s, c->callid.s, ci->callid->len) != 0))
+						(ci->callid->len != c->callid.len ||
+						 strncmp(ci->callid->s, c->callid.s, ci->callid->len) != 0))
 				{
 					ptr = _r->contacts;
 					while (ptr)
 					{
 						ptr0 = ptr->next;
 						if ((ptr != c) && ptr->instance.len == c->instance.len &&
-							strncmp(ptr->instance.s, c->instance.s, ptr->instance.len) == 0)
+								strncmp(ptr->instance.s, c->instance.s, ptr->instance.len) == 0)
 						{
 							ul.delete_ucontact(_r, ptr);
 						}
@@ -912,12 +912,12 @@ int save(struct sip_msg* _m, udomain_t* _d, int _cflags, str *_uri)
 	}
 
 	if (reg_outbound_mode != REG_OUTBOUND_NONE
-		&& !(parse_headers(_m, HDR_VIA2_F, 0) == -1 || _m->via2 == 0
-			|| _m->via2->error != PARSE_OK)) {
+			&& !(parse_headers(_m, HDR_VIA2_F, 0) == -1 || _m->via2 == 0
+				|| _m->via2->error != PARSE_OK)) {
 		/* Outbound supported on server, and more than one Via: - not the first hop */
 
 		if (!(parse_headers(_m, HDR_PATH_F, 0) == -1 || _m->path == 0)) {
-		        route = (rr_t *)0;
+			route = (rr_t *)0;
 			if (parse_rr_body(_m->path->body.s, _m->path->body.len, &route) < 0) {
 				LM_ERR("Failed to parse Path: header body\n");
 				goto error;
@@ -949,7 +949,7 @@ int save(struct sip_msg* _m, udomain_t* _d, int _cflags, str *_uri)
 
 		if ((use_ob == 0) && (reg_regid_mode == REG_REGID_OUTBOUND)) {
 			if ((get_supported(_m) & F_OPTION_TAG_OUTBOUND)
-			    && contact->reg_id) {
+					&& contact->reg_id) {
 				LM_WARN("Outbound used by UAC but not supported by edge proxy\n");
 				rerrno = R_OB_UNSUP_EDGE;
 				goto error;
@@ -959,7 +959,7 @@ int save(struct sip_msg* _m, udomain_t* _d, int _cflags, str *_uri)
 			}
 		}
 	}
-	
+
 	get_act_time();
 	c = get_first_contact(_m);
 
@@ -1012,9 +1012,9 @@ int unregister(struct sip_msg* _m, udomain_t* _d, str* _uri, str *_ruid)
 	if (_ruid == NULL) {
 		/* No ruid provided - remove all contacts for aor */
 
-	        if (extract_aor(_uri, &aor, NULL) < 0) {
-		        LM_ERR("failed to extract Address Of Record\n");
-		        return -1;
+		if (extract_aor(_uri, &aor, NULL) < 0) {
+			LM_ERR("failed to extract Address Of Record\n");
+			return -1;
 		}
 
 		u = parse_to_uri(_m);
@@ -1029,36 +1029,37 @@ int unregister(struct sip_msg* _m, udomain_t* _d, str* _uri, str *_ruid)
 	} else {
 		/* ruid provided - remove a specific contact */
 
-	        if (_uri->len > 0) {
+		if (_uri->len > 0) {
 
-		        if (extract_aor(_uri, &aor, NULL) < 0) {
-		                LM_ERR("failed to extract Address Of Record\n");
-		                return -1;
-		        }
+			if (extract_aor(_uri, &aor, NULL) < 0) {
+				LM_ERR("failed to extract Address Of Record\n");
+				return -1;
+			}
 
-		        if (ul.get_urecord_by_ruid(_d, ul.get_aorhash(&aor),
-						   _ruid, &r, &c) != 0) {
-			        LM_WARN("AOR/Contact not found\n");
-			        return -1;
+			if (ul.get_urecord_by_ruid(_d, ul.get_aorhash(&aor),
+						_ruid, &r, &c) != 0) {
+				LM_WARN("AOR/Contact not found\n");
+				return -1;
 			}
 			if (ul.delete_ucontact(r, c) != 0) {
-			        LM_WARN("could not delete contact\n");
-			        return -1;
+				ul.unlock_udomain(_d, &aor);
+				LM_WARN("could not delete contact\n");
+				return -1;
 			}
 			ul.unlock_udomain(_d, &aor);
 
 		} else {
 
-   		        res = ul.delete_urecord_by_ruid(_d, _ruid);
+			res = ul.delete_urecord_by_ruid(_d, _ruid);
 			switch (res) {
-			case -1:
-			        LM_ERR("could not delete contact\n");
-			        return -1;
-			case -2:
-			        LM_WARN("contact not found\n");
-			        return -1;
-			default:
-			        return 1;
+				case -1:
+					LM_ERR("could not delete contact\n");
+					return -1;
+				case -2:
+					LM_WARN("contact not found\n");
+					return -1;
+				default:
+					return 1;
 			}
 
 		}
-- 
1.8.4.3

